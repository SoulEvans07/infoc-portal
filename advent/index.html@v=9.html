<!DOCTYPE html>
<html lang="hu">

<head>
<meta charset="utf-8">
<title>TEST InfoC :: Adventi naptár</title>
<meta property="og:title" content="TEST InfoC :: Adventi naptár">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="TEST InfoC :: Adventi naptár">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="TEST InfoC :: Adventi naptár">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<link rel="stylesheet" href="../modulz/alap-infoc.css@v101.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v101.css">
<script>var infoc = { onloads: [] };</script>
<script src="../modulz/site.js@v101"></script>
</head>

<body class=" doksi-formatum" data-version="101"
    data-halozati-hiba="Hálózati hiba a kérés teljesítése közben."
    data-tul-nagy-keres="A fájl túl nagy!"
    data-biztos-navigal="Biztos el szeretnél navigálni? A nem mentett változások elvesznek."
    data-ird-be-a-keresoszot="Írd be a keresőszót!"
    data-vissza="Vissza">

<div class="bodycontent">

<nav class="menubg clearfix">
<div class="shaper">
<div id="menu" class="menu menu-font-size">
<a id="menu-nyito" class="menu-nyito"  role="button"><i class="hamburger"></i></a>
<div class="menu-brand"><a href="../index/index.html">InfoC</a></div>
<div id="menu-elemek" class="menu-elemek">
<ul>
<li class="almenu "><a>Infó</a>
<ul>
<li><a  href="../index/index.html">Kezdőlap</a>
<li><a  href="../elerhetoseg/index.html">Elérhetőség</a>
</ul>

<li class="almenu "><a>Tananyag</a>
<ul>
<li class="almenu "><a>Előadás</a>
<ul>
<li><a  href="../ea01/index.html">1. hét: típusok, változók, vezérlés</a>
<li><a  href="../ea02/index.html">2. hét: nevezetes algoritmusok, tömbök</a>
<li><a  href="../ea03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../ea04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../ea05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../ea06/index.html">6. hét: operátorok, számábrázolás</a>
<li><a  href="../ea07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../ea08/index.html">8. hét: fájlkezelés, modulok</a>
<li><a  href="../ea10/index.html">10. hét: láncolt listák</a>
<li><a  href="../ea11/index.html">11. hét: bináris fák</a>
<li><a  href="../ea12/index.html">12. hét: állapotgépek, reguláris kifejezések</a>
<li><a  href="../ea13/index.html">13. hét: generikus algoritmusok, visszalépő keresés</a>
<li><a  href="../ea14/index.html">14. hét: összefoglalás</a>
</ul>

<li class="almenu "><a>Labor</a>
<ul>
<li><a  href="../lab01/index.html">1. hét: parancssor, ZIP</a>
<li><a  href="../lab02/index.html">2. hét: egyszerű programok</a>
<li><a  href="../lab03/index.html">3. hét: tömbök, nevezetes algoritmusok</a>
<li><a  href="../lab04/index.html">4. hét: struktúrák és függvények</a>
<li><a  href="../lab06/index.html">6. hét: pointerek, sztringek</a>
<li><a  href="../lab07/index.html">7. hét: rekurzió</a>
<li><a  href="../lab08/index.html">8. hét: dinamikus tömbök I.</a>
<li><a  href="../lab09/index.html">9. hét: dinamikus tömbök II.</a>
<li><a  href="../lab10/index.html">10. hét: láncolt listák</a>
<li><a  href="../lab11/index.html">11. hét: bináris fák</a>
<li><a  href="../lab12/index.html">12. hét: gyakorlás NZH-ra</a>
<li><a  href="../lab13/index.html">13. hét: állapotgépek</a>
<li><a  href="../lab14/index.html">14. hét: labirintus játék</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../gy01/index.html">1. hét: adatmodellezés, algoritmusok</a>
<li><a  href="../gy02/index.html">2. hét: tanult algoritmusok</a>
<li><a  href="../gy03/index.html">3. hét: egyszerű programok</a>
<li><a  href="../gy04/index.html">4. hét: tételek és tömbök</a>
<li><a  href="../gy05/index.html">5. hét: származtatott típusok</a>
<li><a  href="../gy06/index.html">6. hét: karakterek, számrendszerek</a>
<li><a  href="../gy07/index.html">7. hét: pointerek használata</a>
<li><a  href="../gy08/index.html">8. hét: rekurzió</a>
<li><a  href="../gy09/index.html">9. hét: dinamikus tömbök</a>
<li><a  href="../gy10/index.html">10. hét: láncolt listák</a>
<li><a  href="../gy12/index.html">12. hét: bináris fák</a>
<li><a  href="../gy13/index.html">13. hét: állapotgépek</a>
<li><a  href="../gy14/index.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="almenu "><a>Példatár</a>
<ul>
<li><a  href="../f01/index.html">1. hét: egyszerű programok</a>
<li><a  href="../f02/index.html">2. hét: logika, sorozatok, tömbök</a>
<li><a  href="../f03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../f04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../f05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../f06/index.html">6. hét: számábrázolás, bitek</a>
<li><a  href="../f07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../f08/index.html">8. hét: parancssor, fájlkezelés, modulok</a>
<li><a  href="../f10/index.html">10. hét: láncolt listák</a>
<li><a  href="../f11/index.html">11. hét: bináris fák, többszörös indirekció</a>
<li><a  href="../f12/index.html">12. hét: állapotgépek</a>
<li><a  href="../f13/index.html">13. hét: generikus algoritmusok</a>
</ul>

<li><a  href="../nhflista/index.html">Nagy házi lista</a>
</ul>

<li class="almenu "><a>Segédlet</a>
<ul>
<li><a  href="../jegyzet/index.html">Jegyzet és puska</a>
<li><a  href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a  href="../stilus/index.html">Kódolási stílus</a>
<li><a  href="../for_vs_while/index.html">For vagy while?</a>
<li class="almenu "><a>Nagy házi</a>
<ul>
<li><a  href="../mintanhf/index.html">Minta nagy házi</a>
<li><a  href="../nhfspecifikacio/index.html">Specifikáció: hogyan?</a>
<li><a  href="../debugmalloc/index.html">Debugmalloc, memóriakezelés</a>
<li><a  href="../fajlkezeles/index.html">Fájlkezelés, mappák</a>
<li><a  href="../megjelenites/index.html">Szöveges és grafikus megjelenítés</a>
<li><a  href="../scanf/index.html">Scanf problémák</a>
<li><a  href="../scanf_hibakezeles/index.html">Scanf és hibakezelés</a>
<li><a  href="../karakterkodolas/index.html">Karakterkódolások</a>
<li><a  href="../cbtobbmodul/index.html">Több modulos programok</a>
</ul>

<li class="almenu "><a>ZH</a>
<ul>
<li><a  href="../tldr1/index.html">TL;DR I.</a>
<li><a  href="../tldr2/index.html">TL;DR II.</a>
</ul>

</ul>

<li class="almenu "><a>Extrák</a>
<ul>
<li class="almenu "><a>SVG óra galéria</a>
<ul>
<li><a  href="../orak2021/index.html">SVG óra galéria 2021</a>
<li><a  href="../orak2020/index.html">SVG óra galéria 2020</a>
<li><a  href="../orak2019/index.html">SVG óra galéria 2019</a>
<li><a  href="../orak2018/index.html">SVG óra galéria 2018</a>
<li><a  href="../orak2017/index.html">SVG óra galéria 2017</a>
<li><a  href="../orak2016/index.html">SVG óra galéria 2016</a>
<li><a  href="../orak2015/index.html">SVG óra galéria 2015</a>
</ul>

<li class="almenu "><a>NHF galéria</a>
<ul>
<li><a  href="../nhfgaleria2021/index.html">NHF galéria 2021</a>
<li><a  href="../nhfgaleria2020/index.html">NHF galéria 2020</a>
<li><a  href="../nhfgaleria2019/index.html">NHF galéria 2019</a>
<li><a  href="../nhfgaleria2018/index.html">NHF galéria 2018</a>
<li><a  href="../nhfgaleria2017/index.html">NHF galéria 2017</a>
<li><a  href="../nhfgaleria2016/index.html">NHF galéria 2016</a>
<li><a  href="../nhfgaleria2015/index.html">NHF galéria 2015</a>
<li><a  href="../nhfgaleria2014/index.html">NHF galéria 2014</a>
<li><a  href="../nhfgaleria2013/index.html">NHF galéria 2013</a>
<li><a  href="../nhfgaleria2012/index.html">NHF galéria 2012</a>
</ul>

<li class="almenu "><a>Elmélet</a>
<ul>
<li><a  href="../turing/index.html">Mit tud a számítógép?</a>
<li><a  href="../bf/index.html">BF</a>
<li><a  href="../bitturmix/index.html">Bitturmix</a>
<li><a  href="../kifesto/index.html">Zárt terület kifestése</a>
<li><a  href="../labirintus/index.html">Labirintusok</a>
<li><a  href="../qsort/index.html">Gyorsrendezés</a>
<li><a  href="../tripla/index.html">Tripla indirekció</a>
<li><a  href="../generikus/index.html">Generikus lista</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../strlcpy/index.html">Kulturált sztringmásoló</a>
<li><a  href="../xor_csere/index.html">XOR csere</a>
<li><a  href="../include/index.html">include</a>
<li><a  href="../inline/index.html">inline</a>
<li><a  href="../internet/index.html">Internet</a>
</ul>

<li class="almenu "><a>Grafika</a>
<ul>
<li><a  href="../sdl/index.html">SDL grafika</a>
<li><a  href="../sdl_telepito/index.html">SDL telepítés</a>
<li><a  href="../fa/index.html">Fák rajzolása</a>
</ul>

<li class="almenu "><a>Nyelvészet</a>
<ul>
<li><a  href="../mondatelemzo/index.html">Mondatelemző</a>
<li><a  href="../kifejezesek/index.html">Kifejezések</a>
<li><a  href="../derivalas/index.html">Deriválás</a>
</ul>

<li><a  href="index.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</div>
</nav>

<div class="menu-font-size"><div class="menuplaceholder"></div></div>

<main class="doksi">
<div class="shaper">


<section class="slidescreen" data-title="Adventi naptár">
<div class="slide" id="slide_0">

<a id="0" class="namer"></a>


<div class="slidecontent">
  <div class="float" style="margin-top: 0.25em; margin-bottom: 0;"><button type="button" class="vissza" onclick="history.back();">Vissza</button></div>
<h1 class="eloadascim">Adventi naptár</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán · <i class="ido"></i> 2019.02.27.</p>
<p class="kivonat"></p>
</div>
<h2>Eszköztárak</h2>

<p>Írjunk SDL programot, amelyik kirajzol gombokat, csúszkákat 
és egy színes téglalapot! A csúszkákból legyen három darab. 
Ezekre kattintva lehessen beállítani a vörös, zöld, és kék 
színkomponenseket (RGB), amelyeknek megfelelő színű lesz a téglalap, 
miután az egyik gombra kattintott a felhasználó. A másik gombbal 
lehessen kilépni a programból.</p>

<blockquote>
<p>Ennek az írásnak nem célja, hogy objektumorientált programozás bevezető legyen.
Pár dolog elő fog azért kerülni, de inkább csak problémafelvetésként.
A megértéshez szükséges az előadáson említett <code>union</code> és függvényre
mutató pointer témakörök ismerete.</p>
</blockquote>




  
        <nav id="tartalom">
      <h3>Tartalom</h3>
      <ol>              <li><a href="index.html@v=9.html#1" class="">Widgetek</a>
              <li><a href="index.html@v=9.html#2" class="">A callbackek</a>
              <li><a href="index.html@v=9.html#3" class="">Fogjuk őket össze</a>
              <li><a href="index.html@v=9.html#4" class="">Eszköztárak</a>
            </ol>    </nav>
  </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Widgetek">
<div class="slide" id="slide_1">

<a id="1" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">1</span><span class="oldalszamafter">. </span>    Widgetek<a class="hlink" href="index.html@v=9.html#1"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  <img class="float" src="advent9-ablak.png">

<p>A grafikus felhasználói felületek elemeit angolul <em>widget</em>-nek szokták nevezni. Ezek 
egyrészt <em>különbözőek</em> működésükben: a csúszka aktívan reagál a kattintásra (megváltozik 
a tárolt érték), a színes téglalap nem csinál semmit. Másrészt <em>hasonlítanak is egymásra,</em>
abban, hogy van egy pozíciójuk és egy méretük a képernyőn. Bizonyos szempontból rokonok.

<p>A hasonlóságaik:
<ul>
    <li>Mindegyiknek van helye (x, y) és mérete (szélesség, magasság) a képernyőn.
    <li>Mindegyiknek van egy sötét színű kerete, és egy árnyékolt háttere.
    <li>Mindegyikről meg kell tudnia mondani a programnak, hogy arra kattintott-e a
        felhasználó.
</ul>

<p>A különbségek:
<ul>
    <li>A színes téglalap megjelenít egy színt, de nem reagál a kattintásra.
    <li>A csúszkák reagálnak a kattintásra, és mindegyik ugyanúgy működik.
    <li>A gombokon felirat van, de a feliratok különbözőek. Ugyancsak, a kattintás hatására
        eltérő dolog történik.
    <li>Gombokon kívül is lehetnek feliratok.
</ul>

<p><p>
Az előadáson szerepelt, hogy eltérő típusú adatokat tárolni ugyanazon az adatterületen
<code>union</code> segítségével lehet. Ez nagyon C-s. Valami ilyesmit csinálhatunk:

<pre   ><code class="language-c">/* egy widget, az altalanos es a specialis adatokkal */
typedef struct Widget Widget;
struct Widget {
    int x, y, szeles, magas;            /* pozicio es meret */
 
    enum WidgetTipus {                  /* ilyen típusú lehet */
        gomb, gorditosav, szinesteglalap, felirat
    } tipus;
    union {
        struct {
            char felirat[20];           /* a gomb szövege */
        } gomb;
        struct {
            double jelenlegi;           /* erteke; 0.0-1.0 */
        } gorditosav;
        struct {
            unsigned char r, g, b;      /* szin */
        } szinesteglalap;
        struct {
            char szoveg[20];
        } felirat;
    } adat;
};</code></pre>

<p>
A megadott típus alapján ki tudjuk választani, hogy egy bizonyos <code>Widget</code>
típusú struktúra milyen fajta adatait tárolja; és az alapján tudunk választani a
<code>union</code>-ben lévő adatok közül a megfelelő struktúrát. Ugyancsak, ha
megírjuk a különböző függvényeket, amelyek egy gombot, vagy egy csúszkát
rajzolnak ki a képernyőre, akkor ki tudjuk választani egy widgethez a megfelelőt.
Ehhez azonban minden egyes helyen, ahol rajzolást kell csinálni, egy <code>switch()</code>
kellene; ezt elkerülendő, inkább minden egyes elemben tároljunk el egy pointert is,
amely az elemnek a <em>saját</em> kirajzoló függvényére mutat. Vagyis legyen még
egy ilyen adattag is a struktúrában:

<pre   ><code class="language-c">void (*rajzolo_fv)(Widget *widget);</code></pre>


<p>Bár különfélék, a <code>union</code> használata miatt a <code>Widget</code> struktúra 
egységes C típus minden fajta elemhez. Ez azért jó, mert berakhatjuk ezeket az elemeket egy 
tömbbe (a tömb ugyebár egyforma típusú elemek tárolója); ha a felhasználó kattint egyet valahova 
(x, y koordináta), akkor a tömbben lévő összes elem mérete és pozíciója alapján el tudjuk 
dönteni, hogy konkrétan melyikre. Mivel ennek eldöntéséhez csak azt kell tudni, hogy melyik 
widget hol van az ablakban, azt nem, hogy mi az, az ezt kezelő programrész egységes lehet. Egy 
egyszerű <code>for()</code> ciklust kapunk! Bár a tömb számunkra eltérő típusú elemeket 
tartalmaz, a ciklus közösen tudja kezelni őket, a közös tulajdonságaik alapján.

<p>Nézzük meg a csúszkát közelebbről! Ha egy ilyenre kattint a felhasználó, akkor be tud állítani 
egy színkomponenst. Ha a bal szélére kattint, akkor minimális lesz, ha a jobb szélére, akkor 
maximális. Ezt egy 0 és 1 közötti <code>double</code> értékkel tárolható. Minden csúszka 
ugyanúgy viselkedik, és mindegyiknek a kattintás koordinátáit is kell tudnia (mert látniuk kell, 
melyik részük fölött volt az egérmutató). Írni kell tehát egy függvényt, amelyik egy csúszkán 
belüli kattintást dolgoz fel. Az <code>x</code> és <code>y</code> relatív koordináták, a csúszka bal 
felső sarkához képest:

<pre   ><code class="language-c">void csuszka_kattintas(Widget *csuszka, int x, int y) {
    csuszka-&gt;adat.csuszka.jelenlegi=(double) (x-1)/(csuszka-&gt;szeles);
    csuszka_rajzol(csuszka);
}</code></pre>

<p>A kirajzolása pedig így nézhet ki. Először meghívja a <code>widget_alap_rajzol()</code> 
függvényt, amelyik amúgy mindegyik típusra működik; ez rajzolja a keretet az adott widget köré, és a 
színátmenetet háttérnek. Ehhez azért van külön függvény, mert mindegyikre közös. Ha azt 
változtatjuk, így majd az összes widget egységesen vált kinézetet. A csúszka ezután kirajzolja 
a saját belsejét; ami egyszerűen egy színes csík:

<pre   ><code class="language-c">void csuszka_rajzol(Widget *csuszka) {
    widget_alap_rajzol(csuszka);
    boxColor(renderer, csuszka-&gt;x, csuszka-&gt;y,
        csuszka-&gt;x+csuszka-&gt;szeles * csuszka-&gt;adat.csuszka.jelenlegi,
        csuszka-&gt;y+csuszka-&gt;magas-1, csuszkaszin);
}</code></pre>




  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="A callbackek">
<div class="slide" id="slide_2">

<a id="2" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">2</span><span class="oldalszamafter">. </span>    A callbackek<a class="hlink" href="index.html@v=9.html#2"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>Mi a helyzet a gombokkal? A gombok eltérő dolgot 
csinálnak; az egyikre kattintva a téglalap átszíneződik, a másik pedig bezárja a programot. Az 
viszont közös bennük, hogy a kattintás hatására történik valami, aminek amúgy nincs is köze a 
gomb belső lelkivilágához. Ezt egy függvényre mutató pointerrel lehet jól megoldani; az egyik 
gomb a téglalap átszínezéséhez tartozó függvényt kapja, a másik pedig egy olyan függvényt, 
amelyik befejezi a programot. Ezzel általánosíthatjuk egy gomb működését. Egy programban 
többféle gombot hozhatunk létre, amelyek mind mást csinálnak.

<p>Ami nagyon fontos, hogy így az egyes tevékenységekhez tartozó függvényeket nem kell beírnunk 
a grafikus programrészek (gomb rajzolása, egérkattintások kezelése stb.) közé. A dolgot tovább 
általánosíthatjuk, ha nem csak a gombokhoz rendelünk hozzá ilyen ún. <em>callback</em> függvényt 
(amelyre mutató pointert a grafikus modulnak adunk, és az kattintás esetén <em>visszahívja</em> 
azt), hanem észrevesszük, hogy bármelyik widgethez társítható ilyen. Létrehozhatunk ennek 
segítségével egy speciális, a többitől eltérő működésű csúszkát is, vagy olyan színes 
téglalapot, amely képes valami módon a kattintásokra reagálni. Például az egérgombot nyomva 
tartva rajzolni lehet rá. Ha nincs szükség callbackre, akkor pedig a függvénypointer 
<code>NULL</code> lehet, ezzel jelezzük a grafikus modulnak, hogy az a widget passzív.

<pre   ><code class="language-c">widgetek[0]=uj_gomb(216, 10, 50, 32, &quot;Kilép&quot;);
widgetek[0]-&gt;felhasznaloi_cb=kilep_gomb_cb;      /* programból kilépés */
widgetek[7]=uj_gomb(10, 170, 50, 32, &quot;Mehet&quot;);
widgetek[7]-&gt;felhasznaloi_cb=mehet_gomb_cb;      /* csúszkák alapján szín beállítása */</code></pre>

<p>Ennél is tovább általánosítható a dolog. Ha az alsó, Mehet feliratú gombra kattintunk, akkor 
a három csúszka aktuális értéke alapján állítódik be a téglalap színe. Az ezt végző függvénynek, 
amelyik a gomb callbackje, ismernie kell a három csúszkát és a téglalapot. Ezeket a callback 
paramétereként kell átvegye:

<pre   ><code class="language-c">typedef struct UIAdat {
    Widget *r, *g, *b, *teglalap;
} UIAdat;</code></pre>

<p>De ennek tartalmával foglalkozni nem a gomb dolga, hanem a gomb használójáé.
Hogy ne kössünk meg semmit a grafikus modul írásakor, az extra 
paraméter típusa, az előadáson bemutatott adatokhoz hasonlóan <code>void*</code> lehet. Egy 
<code>void*</code> mutatóval bármire rámutathatunk; ha egynél több paraméter kell, akkor azokat 
berakjuk egy struktúrába, és az arra mutató pointert veszi át a callback. A függvény belsejében 
ezt a típus nélküli pointert a saját típusra vissza kell majd alakítani; hasonlóan ahhoz, 
ahogyan egy <code>qsort()</code>-hoz való összehasonlító függvényben is kell. A widgetek 
általános tulajdonságaihoz ezért a lenti mezőket is hozzátesszük. (Az x és y koordináta azért 
szerepel itt is, hátha olyan callbacket akarunk írni, amelyik figyelembe veszi azt is. A gomb 
ebben a programban nem használja a kapott értékeket.)

<p>Észrevéve, hogy tulajdonképp a widget saját működését is ilyen függvényen keresztül
végezhetjük, végülis két függvénypointert teszünk minden widgetbe. Az egyik a
belső működését adja (pl. a csúszka állítható), a másik pedig a felhasználói felületben
a hozzá társított működés:</p>

<pre   ><code class="language-c">/* belso lelkivilag: ha a kattintasra kell valamit csinalni, pl. csuszka erteke */
void (*kattintas_fv)(Widget *widget, int x, int y);

/* kivulrol tarsitott mukodes, a beepitett mukodesen tul */
void (*felhasznaloi_cb)(Widget *widget, int x, int y, void *param);
void *felhasznaloi_cb_param;           /* ezt a parametert megkapja a param valtozoban */</code></pre>




  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Fogjuk őket össze">
<div class="slide" id="slide_3">

<a id="3" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">3</span><span class="oldalszamafter">. </span>    Fogjuk őket össze<a class="hlink" href="index.html@v=9.html#3"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  <p>
Az előbb már szó esett róla, hogy a widgetek egy tömbbe kerülnek. A tömb a programban
pointereket tartalmaz; az egyes widgeteket dinamikusan lehet foglalni le. Minden típushoz
tartozik egy külön függvény; a függvény végzi a memóriafoglalást, és a paraméterek
alapján a tulajdonságok beállítását. A csúszka példája lent látható.
Az <code>uj_widget()</code> függvény feladata
a memória foglalása, és a méretek beállítása; ezt mindegyik típusnál meg kell
csinálni, ezért külön függvény lett belőle. A többi paramétert egyszerűen be kell másolni. 

<pre   ><code class="language-c">Widget *uj_csuszka(int x, int y, int szeles, int magas, double kezdeti) {
    Widget *uj=uj_widget(x, y, szeles, magas);
    uj-&gt;tipus=csuszka;
    uj-&gt;rajzolo_fv=csuszka_rajzol;        /* ezzel rajzolodik ki */
    uj-&gt;kattintas_fv=csuszka_kattintas;   /* a sajat, belso mukodese */
    uj-&gt;adat.csuszka.jelenlegi=kezdeti;
    return uj;
}</code></pre>

<p>Az eseményhurok megkapja a felhasználótól érkező kattintásokat. Az SDL a kattintások adatai 
mellé megadja a koordinátát. Így könnyű megkeresni azt a widgetet, amelyiknek a területén 
éppen az egérmutató volt abban a pillanatban. A widget típusától függően ilyenkor elindulhat egy 
beépített függvény (ez a helyzet a csúszkák esetén), és ha van, lefut egy külön megadott 
callback (ez pedig a gombok esetén). Mivel ezek hatására a widgetek esetleg megváltozhattak, az 
újrarajzolás miatt meghívja az <code>SDL_RenderPresent()</code> függvényt.

<p>A <code>main()</code> függvényben létrejönnek az egyes widgetek. Az átszínező gombhoz a 
fentiek alapján egy struktúrába kerülnek be a kezelt widgetekre mutató pointerek. Miután minden 
kész, az <code>esemenyvezerelt_main()</code> függvény indul el; és onnantól kezdve a program 
mindent a felhasználói input alapján csinál. A bejövő eseményeknél meghatározza, hogy melyik 
widgetnek szólnak. A widgetek callbackjai, egészen pontosan az alsó gombé pedig a fent leírt 
feladatot valósítja meg: hogy a beállított színkomponensek alapján a kattintás hatására a 
téglalapnak új színt ad. Ennek lelke az <code>mehet_gomb_cb()</code> függvény; a program többi 
része a felület elemeinek leprogramozása.

<p>A programból kilépő gomb hatására az eseményhuroknak (a <code>while</code> ciklus) be kell 
fejeződnie. Ez úgy is megoldható, hogy a hozzá tartozó callback egy <code>SDL_QUIT</code> típusú 
eseményt rak az SDL esemény várakozási sorának végére. Így pontosan ugyanaz lesz a hatása, mint 
az ablak bezárásának. Persze más megoldást is el lehet képzelni erre.



  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Eszköztárak">
<div class="slide" id="slide_4">

<a id="4" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">4</span><span class="oldalszamafter">. </span>    Eszköztárak<a class="hlink" href="index.html@v=9.html#4"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>A program forráskódja pedig letölthető innen:
<a href="advent9-widget.c">advent9-widget.c</a>. Az SDL-es program fordításához az extrák menüpont alatt segítség.

<p>Senkinek nem ajánlom, hogy maga kezdjen toolkitet, vagyis eszköztárat kódolni. Ez az írás 
azért született, hogy bemutassa, egy ilyen nagyjából hogy működik belülről, illetve néhány 
általános problémára és megoldási lehetőségre rávilágítson. Több platformfüggetlen eszközkészlet 
is létezik. Ha nincs megkötve, érdemes ezek közül választani, hiszen a platformfüggetlenség nagy 
előny bármely program számára. Néhány ismertebb:

<ul>
    <li>GTK+: Linuxból származik, C-ben íródott. Néhány ötletet ehhez a programhoz a GTK+-ból
        vettem. Működik Windowson, Linuxon és Macen is.
    <li>wxWidgets: C++-os. Érdekessége, hogy minden operációs rendszeren a natív widgeteket
        használja – vagyis nem maga rajzolgatja ki azokat. Így minden operációs
        rendszeren a vele írt programok úgy néznek ki, mint a másik ottani programok.
        A Code::Blocks ezzel készült.
    <li>Qt: a KDE alapja, ez is C++-ban íródott.
</ul>

<p>Viszont ez a toolkit még elő fog kerülni az adventi naptárban, egy későbbi napon.
  
    </div>

<div class="clear"></div>

</div>
</section>

</div>
</main>

<footer role="contentinfo">
<div class="shaper">
<div class="footer ">
  <a href="../index/index.html"><img src="../modulz/logo.png" class="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon">
            <a href="../index/index.html">főoldal</a>
         ·     <a href="../elerhetoseg/index.html">elérhetőség</a>
         ·     <a href="../elerhetoseg/index.html#licenc">licenc</a>
         ·     <a href="https://www.facebook.com/infoceetbmehu">facebook</a>
    </div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2021.</div>
</div>
</footer>

</div>

<nav>
<a id="scrolltotop"></a>
</nav>

</body>

</html>
