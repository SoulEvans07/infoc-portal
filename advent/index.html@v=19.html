<!DOCTYPE html>
<html lang="hu">

<head>
<meta charset="utf-8">
<title>TEST InfoC :: Adventi naptár</title>
<meta property="og:title" content="TEST InfoC :: Adventi naptár">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="TEST InfoC :: Adventi naptár">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="TEST InfoC :: Adventi naptár">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<link rel="stylesheet" href="../modulz/alap-infoc.css@v101.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v101.css">
<script>var infoc = { onloads: [] };</script>
<script src="../modulz/site.js@v101"></script>
</head>

<body class=" doksi-formatum" data-version="101"
    data-halozati-hiba="Hálózati hiba a kérés teljesítése közben."
    data-tul-nagy-keres="A fájl túl nagy!"
    data-biztos-navigal="Biztos el szeretnél navigálni? A nem mentett változások elvesznek."
    data-ird-be-a-keresoszot="Írd be a keresőszót!"
    data-vissza="Vissza">

<div class="bodycontent">

<nav class="menubg clearfix">
<div class="shaper">
<div id="menu" class="menu menu-font-size">
<a id="menu-nyito" class="menu-nyito"  role="button"><i class="hamburger"></i></a>
<div class="menu-brand"><a href="../index/index.html">InfoC</a></div>
<div id="menu-elemek" class="menu-elemek">
<ul>
<li class="almenu "><a>Infó</a>
<ul>
<li><a  href="../index/index.html">Kezdőlap</a>
<li><a  href="../elerhetoseg/index.html">Elérhetőség</a>
</ul>

<li class="almenu "><a>Tananyag</a>
<ul>
<li class="almenu "><a>Előadás</a>
<ul>
<li><a  href="../ea01/index.html">1. hét: típusok, változók, vezérlés</a>
<li><a  href="../ea02/index.html">2. hét: nevezetes algoritmusok, tömbök</a>
<li><a  href="../ea03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../ea04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../ea05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../ea06/index.html">6. hét: operátorok, számábrázolás</a>
<li><a  href="../ea07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../ea08/index.html">8. hét: fájlkezelés, modulok</a>
<li><a  href="../ea10/index.html">10. hét: láncolt listák</a>
<li><a  href="../ea11/index.html">11. hét: bináris fák</a>
<li><a  href="../ea12/index.html">12. hét: állapotgépek, reguláris kifejezések</a>
<li><a  href="../ea13/index.html">13. hét: generikus algoritmusok, visszalépő keresés</a>
<li><a  href="../ea14/index.html">14. hét: összefoglalás</a>
</ul>

<li class="almenu "><a>Labor</a>
<ul>
<li><a  href="../lab01/index.html">1. hét: parancssor, ZIP</a>
<li><a  href="../lab02/index.html">2. hét: egyszerű programok</a>
<li><a  href="../lab03/index.html">3. hét: tömbök, nevezetes algoritmusok</a>
<li><a  href="../lab04/index.html">4. hét: struktúrák és függvények</a>
<li><a  href="../lab06/index.html">6. hét: pointerek, sztringek</a>
<li><a  href="../lab07/index.html">7. hét: rekurzió</a>
<li><a  href="../lab08/index.html">8. hét: dinamikus tömbök I.</a>
<li><a  href="../lab09/index.html">9. hét: dinamikus tömbök II.</a>
<li><a  href="../lab10/index.html">10. hét: láncolt listák</a>
<li><a  href="../lab11/index.html">11. hét: bináris fák</a>
<li><a  href="../lab12/index.html">12. hét: gyakorlás NZH-ra</a>
<li><a  href="../lab13/index.html">13. hét: állapotgépek</a>
<li><a  href="../lab14/index.html">14. hét: labirintus játék</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../gy01/index.html">1. hét: adatmodellezés, algoritmusok</a>
<li><a  href="../gy02/index.html">2. hét: tanult algoritmusok</a>
<li><a  href="../gy03/index.html">3. hét: egyszerű programok</a>
<li><a  href="../gy04/index.html">4. hét: tételek és tömbök</a>
<li><a  href="../gy05/index.html">5. hét: származtatott típusok</a>
<li><a  href="../gy06/index.html">6. hét: karakterek, számrendszerek</a>
<li><a  href="../gy07/index.html">7. hét: pointerek használata</a>
<li><a  href="../gy08/index.html">8. hét: rekurzió</a>
<li><a  href="../gy09/index.html">9. hét: dinamikus tömbök</a>
<li><a  href="../gy10/index.html">10. hét: láncolt listák</a>
<li><a  href="../gy12/index.html">12. hét: bináris fák</a>
<li><a  href="../gy13/index.html">13. hét: állapotgépek</a>
<li><a  href="../gy14/index.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="almenu "><a>Példatár</a>
<ul>
<li><a  href="../f01/index.html">1. hét: egyszerű programok</a>
<li><a  href="../f02/index.html">2. hét: logika, sorozatok, tömbök</a>
<li><a  href="../f03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../f04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../f05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../f06/index.html">6. hét: számábrázolás, bitek</a>
<li><a  href="../f07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../f08/index.html">8. hét: parancssor, fájlkezelés, modulok</a>
<li><a  href="../f10/index.html">10. hét: láncolt listák</a>
<li><a  href="../f11/index.html">11. hét: bináris fák, többszörös indirekció</a>
<li><a  href="../f12/index.html">12. hét: állapotgépek</a>
<li><a  href="../f13/index.html">13. hét: generikus algoritmusok</a>
</ul>

<li><a  href="../nhflista/index.html">Nagy házi lista</a>
</ul>

<li class="almenu "><a>Segédlet</a>
<ul>
<li><a  href="../jegyzet/index.html">Jegyzet és puska</a>
<li><a  href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a  href="../stilus/index.html">Kódolási stílus</a>
<li><a  href="../for_vs_while/index.html">For vagy while?</a>
<li class="almenu "><a>Nagy házi</a>
<ul>
<li><a  href="../mintanhf/index.html">Minta nagy házi</a>
<li><a  href="../nhfspecifikacio/index.html">Specifikáció: hogyan?</a>
<li><a  href="../debugmalloc/index.html">Debugmalloc, memóriakezelés</a>
<li><a  href="../fajlkezeles/index.html">Fájlkezelés, mappák</a>
<li><a  href="../megjelenites/index.html">Szöveges és grafikus megjelenítés</a>
<li><a  href="../scanf/index.html">Scanf problémák</a>
<li><a  href="../scanf_hibakezeles/index.html">Scanf és hibakezelés</a>
<li><a  href="../karakterkodolas/index.html">Karakterkódolások</a>
<li><a  href="../cbtobbmodul/index.html">Több modulos programok</a>
</ul>

<li class="almenu "><a>ZH</a>
<ul>
<li><a  href="../tldr1/index.html">TL;DR I.</a>
<li><a  href="../tldr2/index.html">TL;DR II.</a>
</ul>

</ul>

<li class="almenu "><a>Extrák</a>
<ul>
<li class="almenu "><a>SVG óra galéria</a>
<ul>
<li><a  href="../orak2021/index.html">SVG óra galéria 2021</a>
<li><a  href="../orak2020/index.html">SVG óra galéria 2020</a>
<li><a  href="../orak2019/index.html">SVG óra galéria 2019</a>
<li><a  href="../orak2018/index.html">SVG óra galéria 2018</a>
<li><a  href="../orak2017/index.html">SVG óra galéria 2017</a>
<li><a  href="../orak2016/index.html">SVG óra galéria 2016</a>
<li><a  href="../orak2015/index.html">SVG óra galéria 2015</a>
</ul>

<li class="almenu "><a>NHF galéria</a>
<ul>
<li><a  href="../nhfgaleria2021/index.html">NHF galéria 2021</a>
<li><a  href="../nhfgaleria2020/index.html">NHF galéria 2020</a>
<li><a  href="../nhfgaleria2019/index.html">NHF galéria 2019</a>
<li><a  href="../nhfgaleria2018/index.html">NHF galéria 2018</a>
<li><a  href="../nhfgaleria2017/index.html">NHF galéria 2017</a>
<li><a  href="../nhfgaleria2016/index.html">NHF galéria 2016</a>
<li><a  href="../nhfgaleria2015/index.html">NHF galéria 2015</a>
<li><a  href="../nhfgaleria2014/index.html">NHF galéria 2014</a>
<li><a  href="../nhfgaleria2013/index.html">NHF galéria 2013</a>
<li><a  href="../nhfgaleria2012/index.html">NHF galéria 2012</a>
</ul>

<li class="almenu "><a>Elmélet</a>
<ul>
<li><a  href="../turing/index.html">Mit tud a számítógép?</a>
<li><a  href="../bf/index.html">BF</a>
<li><a  href="../bitturmix/index.html">Bitturmix</a>
<li><a  href="../kifesto/index.html">Zárt terület kifestése</a>
<li><a  href="../labirintus/index.html">Labirintusok</a>
<li><a  href="../qsort/index.html">Gyorsrendezés</a>
<li><a  href="../tripla/index.html">Tripla indirekció</a>
<li><a  href="../generikus/index.html">Generikus lista</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../strlcpy/index.html">Kulturált sztringmásoló</a>
<li><a  href="../xor_csere/index.html">XOR csere</a>
<li><a  href="../include/index.html">include</a>
<li><a  href="../inline/index.html">inline</a>
<li><a  href="../internet/index.html">Internet</a>
</ul>

<li class="almenu "><a>Grafika</a>
<ul>
<li><a  href="../sdl/index.html">SDL grafika</a>
<li><a  href="../sdl_telepito/index.html">SDL telepítés</a>
<li><a  href="../fa/index.html">Fák rajzolása</a>
</ul>

<li class="almenu "><a>Nyelvészet</a>
<ul>
<li><a  href="../mondatelemzo/index.html">Mondatelemző</a>
<li><a  href="../kifejezesek/index.html">Kifejezések</a>
<li><a  href="../derivalas/index.html">Deriválás</a>
</ul>

<li><a  href="index.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</div>
</nav>

<div class="menu-font-size"><div class="menuplaceholder"></div></div>

<main class="doksi">
<div class="shaper">


<section class="slidescreen" data-title="Adventi naptár">
<div class="slide" id="slide_0">

<a id="0" class="namer"></a>


<div class="slidecontent">
  <div class="float" style="margin-top: 0.25em; margin-bottom: 0;"><button type="button" class="vissza" onclick="history.back();">Vissza</button></div>
<h1 class="eloadascim">Adventi naptár</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán · <i class="ido"></i> 2019.02.27.</p>
<p class="kivonat"></p>
</div>
<h2>Fraktál tájképek és 3D rajzolás</h2>

<img src="advent19-hegy.jpg" class="kozep arnyek">

<p>Tetszik ez a hegy? Remélhetőleg igen, mert ilyeneket fog rajzolni a mai program. Ehhez két dolgot kell csinálnia:
<ul>
    <li>egy domborzati térképet kell generálnia, és
    <li>kirajzolni a térkép alapján megalkotott görbe felületet.
</ul>



  
        <nav id="tartalom">
      <h3>Tartalom</h3>
      <ol>              <li><a href="index.html@v=19.html#1" class="">A fraktál tájképek</a>
              <li><a href="index.html@v=19.html#2" class="">A hegy kirajzolása</a>
            </ol>    </nav>
  </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="A fraktál tájképek">
<div class="slide" id="slide_1">

<a id="1" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">1</span><span class="oldalszamafter">. </span>    A fraktál tájképek<a class="hlink" href="index.html@v=19.html#1"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>A teknőcgrafika kapcsán láttuk, hogy némely fraktálok úgy alakíthatók ki, hogy egy alakzatot minden
lépésben bonyolítunk egy kicsit. Lehet egy ötletünk ezzel kapcsolatban: vigyünk be egy kis 
véletlenszerűséget ebbe a lépésbe! Az alábbi rajzon egy egyszerű szakasz látható, amelyet
ilyen módon bonyolítunk. Minden egyes lépésben fogjuk a szakaszt vagy szakaszokat, és azoknak középpontját
eltoljuk felfelé vagy lefelé véletlenszerűen, kettétörve ezzel azokat. A véletlenszerű eltolás
mértékét pedig aszerint csökkentjük, hogy mekkora szakaszt felezünk. Az elején még nagyokat
ugrunk, aztán egyre kisebbeket. Látható, hogy így egy hegy alakul ki:

<img src="advent19-hegyfraktal.svg" class="kozep" style="width: 40em;">

<img src="advent19-plazma.jpg" class="float arnyek">

<p>Nem kell mást tennünk, mint azt, hogy ezt általánosítanunk két dimenzióra, és már kész is a domborzati 
térkép. Egyik adventi bejegyzésben már történt hasonló dolog: a „plazma fraktálnak” csúfolt algoritmus 
éppen ezt csinálta. Annyi hiányossággal, hogy nem túl szépen tette ezt: az ábrán vízszintes és 
függőleges vonalak ismerhetőek fel, látszik rajta, hogy a generáló algoritmus vízszintesen és 
függőlegesen haladva átlagolja és tolja el a színeket. (A színek jelentik itt a szakasz y 
koordinátáját, az átlagolás pedig a szakasz kettéosztását: a szakasz két széle végpontjának y 
koordinátáit átlagolva a közepének y koordinátáját kapjuk.)

<p>Egy ügyes trükkel azonban lehet ezen segíteni. Ezt a trükköt a gyémánt–négyzet algoritmus
(diamond-square algorithm) valósítja meg. Működését nagyon könnyű megérteni az alábbi
rajzok alapján.

<p>Az eredeti, hibás algoritmus úgy működött, hogy minden négyzet (négy szomszédos kék pötty) által
közrezárt középső, zölddel jelölt pont színét a négy pont színének átlagából számolta ki, azt egy kis
véletlenszámmal módosítva. Az egyes kék pontok közötti pirossal jelölt pontok színét pedig
egyszerűen azokat átlagolva. Ezért alakultak ki a vízszintes-függőleges mintázatok, mert a pirossal
jelölt pontok színét csak a vízszintes-függőleges szomszédaik alapján számolta az algoritmus.

<div class="columns">
<div>
    <img src="advent19-square.svg" class="kozep" style="max-width: 18em;">
    <div class="kozep">a négyzet (eredeti)</div>
</div>
<div>
    <img src="advent19-diamondsquare.svg" class="kozep" style="max-width: 18em;">
    <div class="kozep">a négyzet és a gyémánt (javított)</div>
</div>
</div>

<p>A javított változat ezzel szemben így gondolkozik: számoljuk ki a 
zölddel jelölt pontok színét az előbbi módon, azonban ezek után a 
pirossal jelölt pontok színét pedig határozzuk meg úgy, hogy azok 
függjenek a most generált zöld pontoktól is! A zöld pontok kiszámolását 
nevezik a „négyzet lépésnek”, mivel a zöld pontok színét meghatározó 
kék pontok négyzet alakban helyezkednek el. A piros pontok 
kiszámolása pedig a „gyémánt lépés”, mert minden piros pontot 
meghatározó kék pontok (felette, alatta) és zöld pontok (tőle balra, 
jobbra) gyémánt alakban helyezkednek el. Mintha az egész ábrát 
elforgatnánk 45 fokkal a gyémánt lépés idejére, és úgy átlagolnánk a 
négyzet alakban elhelyezkedő pontokat.
Alább látható egy fraktál, amelyet az így javított algoritmus 
generált. Látható, hogy ebben már nincsenek meg az előbbiben 
halványan még felfedezhető vízszintes és függőleges csíkok.

<p>Na és hogy lesz ebből hegy? Egyszerűen! A generált számokat 
magasságértékeknek és színeknek is használjuk. A legkisebb, -1 körüli
számok az alacsony magasságot jelzik, és kék színt kapnak (az lesz a
hegyi tó). Utána egy hirtelen átmenettel a zöld jön, aztán a barna, 
és végül a fehér. A legmagasabb, +1 körüli helyeken lesz a fehér a
hó színe.

<div class="columns">
    <div>
    <img src="advent19-plazmaoke.jpg" class="kozep arnyek" style="max-width: 80%">
    </div>
    <div>
    <img src="advent19-hegyoke.jpg" class="kozep arnyek" style="max-width: 80%">
    </div>
</div>


<p>A szélső pontok problémásak még az algoritmus szempontjából. A bal
szélső piros pontnak (lásd az előbbi ábrát) például nincsen bal oldali zöld szomszédja, 
amely meghatározná a színét. Nagyban leegyszerűsíthetjük a 
programunkat, ha a peremek külön esetként kezelése helyett a kép 
másik oldalán lévő pontokat tekintjük szomszédoknak. (Ezt biztosan sokan
csináltátok, akik életjátékot írtatok a nagy háziban.) Például ha a kép
256 képpont széles, akkor a 255-ös pont jobb oldali szomszédjának a 
255+1 = 256 &rarr; 0-s pontot vesszük. Ha a kép mérete kettő valamely
hatványa, ezt egy egyszerű bitenkénti és művelet megoldja mindkét 
irányban, pozitív és negatív „túlindexelés” esetén is. Egy
256×256-os térkép esetén:

<pre   ><code class="language-c">enum { MERET = 1&lt;&lt;8 };                  /* legyen 2 hatvanya! */
typedef double Magassag[MERET][MERET];</code></pre>

<p>A térkép egy adott pontján a magasságot beállító, és a magasságot lekérdező függvény:

<pre   ><code class="language-c">/* beallitja az adott koordinatan a magassagot.
 * x es y ket oldalt &quot;tulpordul&quot; */
void beallit(Magassag k, int x, int y, double szin) {
    if (szin &lt; -1) szin = -1;
    if (szin &gt; +1) szin = +1;
    k[y &amp; (MERET - 1)][x &amp; (MERET - 1)] = szin;
}

/* kiolvassa a magassagterkeprol az adott koordinatat.
 * x es y koordinata a ket oldalt &quot;tulpordul&quot; */
double magassag(Magassag k, int x, int y) {
    return k[y &amp; (MERET - 1)][x &amp; (MERET - 1)];
}</code></pre>

<p>Ez figyelembe veszi a magasságot megadó szám korlátait is:
-1 lesz a legmélyebb völgy, +1 a legmagasabb hegy, és
valós számokat használunk. A két szélen körbeforduló számítás miatt a
generált fraktál csempézhető is: több darabját egymás mellé rakva a
széleken folytonos átmeneteket kapunk.

<p>Egy négyzet lépés így végezhető el:

<pre   ><code class="language-c">/* negyzet alaku atlagolas. az x, y a cel koordinata, a
 * meret azt mondja meg, hogy mekkora negyzetbol vegye az atlagot */
void negyzet(Magassag k, int x, int y, int meret, double maxelteres) {
    int fel = meret / 2;
    double a = magassag(k, x - fel, y - fel);
    double b = magassag(k, x + fel, y - fel);
    double c = magassag(k, x - fel, y + fel);
    double d = magassag(k, x + fel, y + fel);
 
    beallit(k, x, y, (a + b + c + d)/4.0 + frand()*maxelteres);
}</code></pre>

<p>Ennek megadjuk a kiszámolandó pont koordinátáit (x, y), és annak a négyzetnek a méretét (meret), amelyen belül
az átlagolást el kell végeznie. A maxeltérés paraméter adja meg a legnagyobb véletlenszerű
eltolást, amit csinál. (Az <code>frand()</code> függvényünk -1 és +1 közötti véletlenszámot generál.)
Látszik, hogy ez már nem foglalkozik a kép széleivel: feltételezi, hogy a <code>magassag()</code>
és a <code>beallit()</code> függvénye helyesen kezelik azt. A gyémánt lépés a fentihez hasonlóan működik.

<p>A térkép generálása pedig úgy működik, hogy egyre kisebb, négyzet alakú területeken
végezzük el előbb a négyzet lépést, utána pedig a gyémánt lépést. A területek méretét a <code>lepes</code>
változó adja meg, amelyet először a kép teljes méretétől indítunk, aztán pedig minden iterációban
felezzük, amíg el nem jutunk az egy képpont méretű lépésig – mert addigra készen is vagyunk:

<pre   ><code class="language-c">/* Letrehoz egy uj, veletlenszeru terkepet */
void terkep_general(Magassag k) {
    beallit(k, 0, 0, 0);  /* kiindulopont - legyen mindig kozepmagassag */

    /* mindig megfelezve a darabokat, ujabb pontokat generalunk */
    double maxelteres = 2;
    for (int lepes = MERET; lepes &gt; 1; lepes /= 2) {
        int fellepes = lepes / 2;
        /* negyzetek belseje */
        for (int y = fellepes; y &lt; MERET + fellepes; y += lepes)
            for (int x = fellepes; x &lt; MERET + fellepes; x += lepes)
                negyzet(k, x, y, lepes, maxelteres);
        /* gyemantok belseje */
        for (int y = 0; y &lt; MERET; y += lepes) {
            for (int x = 0; x &lt; MERET; x += lepes) {
                gyemant(k, x + fellepes, y, lepes, maxelteres);
                gyemant(k, x, y + fellepes, lepes, maxelteres);
            }
        }
        maxelteres /= 2;
    }
}</code></pre>

<p>Érdekesség, hogy a térkép generálása nem négy meghatározott pontból, hanem egyetlen egy 
pontból indul. Az első lépése a 256×256-os képen az lesz, hogy elhelyezzen egy véletlenszerű 
pontot a (0;0) koordinátán, és utána elvégezze az első „négyzet lépést”. Gondolhatnánk, hogy 
nincsen négy pont, amit ehhez átlagolni lehetne, de van: a (0;0), a (0;256), a (256;0) és a
(256;256) pontok. Ne feledjük, a képen minden irányban körbesétálhatunk (jobb oldalt ki, bal oldalt
be stb), tehát ezek a pontok léteznek, és átlagolhatóak: tulajdonképpen a (0;0) pontot vesszük 
négyszer, és azt átlagoljuk. Ezután már valójában is létezik több pont, amit átlagolni lehet.

<p>Az első mai letölthető program a térképet rajzolja ki:
<a href="advent19-terkep.c">advent19-terkep.c</a>. A szóköz gomb minden megnyomására egy új
fraktált generál. A színátmeneteket előállító függvény a Mandelbrot-fraktálos programból származik.
A kirajzolás előtt végez a képen egy minimum- és maximumkeresést, hogy utána a legkisebb és a legnagyobb
számot „kihúzza” a -1 és +1 értékekhez – így látszik a teljes színpaletta.
Érdemes játszani egy kicsit az algoritmus paramétereivel (a maxeltérés kezdeti értékével és osztójával) a
<code>terkep_general()</code> függvényben,  és a színekkel a <code>szineket_kiszamol()</code>
függvényben. Nem csak hegyeket lehet ezzel a programmal rajzolni, hanem például felhőket is.











  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="A hegy kirajzolása">
<div class="slide" id="slide_2">

<a id="2" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">2</span><span class="oldalszamafter">. </span>    A hegy kirajzolása<a class="hlink" href="index.html@v=19.html#2"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>Térjünk át a háromdimenziós részre – hiszen adott egy magasságérkép, most már csak ki kellene
rajzolni a görbe felületet, amely a hegyet adja ki.

<div class="columns">
<div>
    <img src="advent19-negyszogeksima.svg" style="width: 16em;" class="kozep">
</div>
<div>
    <img src="advent19-negyszogek.svg" style="width: 16em;" class="kozep">
</div>
</div>

<p>Ahhoz, hogy ez szép legyen, a tegnapi drótvázról át kell térnünk kitöltött sokszögekre.
Ehhez egy egyszerű négyzetrácsból indulhatunk ki. Fogjunk meg tehát egy csomó négyzetet, amelyek
az <code>y=0</code> síkon fekszenek (bal oldali ábra), és toljuk el ezek pontjait függőlegesen
a magasságtérkép szerint (jobb oldali ábra). Bár így már nem négyzetek lesznek, de nem baj,
a hegyet megkapjuk. Ha még színeket is rendelünk az egyes négyszögekhez, már meg is kaptuk azt
a sokszöghalmazt, amelyet ki kell rajzolnunk. Ha van N×N pontunk, (N-1)×(N-1) négyszöget
kell kezelnünk.

<img src="advent19-hegy32.jpg" class="kozep arnyek">

<p>Csakhogy a kirajzolás nem olyan egyszerű, mint a drótváznál. Ugyanis nem dobálhatjuk csak fel 
a négyszögeket a képernyőre tetszés szerinti sorrendben – egyes négyszögek részben vagy teljesen 
elfedhetnek másik példányokat. A fenti drótváz rajzon például az utolsó előtti sor balról második 
négyszöge egyáltalán nem látszik. A repülős játéknál már találkoztunk ezzel a problémával. Ott a 
rossz sorrendű kirajzolás esetén úgy nézett ki, mintha a repülő a fenyőfa alatt ment volna el.

<p>A szép megoldás erre a problémára z-pufferelés (z-buffer) nevű eljárás lenne. Az abból az egyszerű 
felismerésből indul ki, hogy a keletkező két dimenziós képen minden egyes képpont színét pontosan
egy térbeli test határozza meg – mégpedig az, amelyik a legközelebb van abban az irányban. Tehát
a sokszögek kirajzolásakor nem kellene mást tennünk, mint minden egyes térbeli sokszögnek megfelelő
síkbeli sokszög kirajzolásakor kiszámolni azt is, hogy az egyes kiszínezett képpontok milyen
távol vannak a megfigyelőtől, és azt feljegyezni a képpont adata mellé. (Tehát a kép minden pixeléhez
tartozik még egy z érték.) Ha közelebbi képpontot
kell rajzolni, akkor a rajzolást meg kell tenni, és feljegyezni az új távolságot a képponthoz;
ha távolabbit, akkor pedig semmi teendő nincsen.

<p>Az SDL_gfx könyvtárral ezt azonban nem tudjuk megoldani, mert az két dimenzióban számol csak.
Helyettesíthetjük viszont egy újabb trükkel: rendezzük kirajzolás előtt távolság szerint
csökkenő sorrendbe a sokszögeket! Ha a kirajzolandó négyszögek kicsik és nem metszik egymást, 
így is szép ábrát fogunk kapni. Márpedig a négyszögeink kicsik és nem metszik egymást. (Mindenki 
átgondolhatja maga, hogy a két feltétel közül melyik miért fontos.)

<p>Az adatszerkezet hasonló a drótvázas programéhoz. A <code>Pont</code> struktúra tárolja egy
pont térbeli adatait (eredeti és forgatott koordinátáit, képernyőre leképezett koordinátáit),
a <code>Negyszog</code> pedig négy pontra hivatkozik:

<pre   ><code class="language-c">typedef struct Pont {
    double x, y, z;     /* eredeti 3d koordináta */
    double xf, yf, zf;  /* forgatott 3d koordináta */
    int xk, yk;         /* képernyőn koordináta */
} Pont;

typedef struct Negyszog {
    Pont *sarkok[4];
    Uint32 szin;
} Negyszog;</code></pre>

<p>A kirajzolásnál előbb elforgatjuk irányba az összes pontot, utána rendezzük a négyszögeket
távolság szerint, végül pedig elvégezzük a rajzolást:

<pre   ><code class="language-c">void kirajzol(Pont pontok[], Negyszog negyszogek[], double fx, double fy) {
    boxRGBA(screen, 0, 0, ABLAK_SZ, ABLAK_M, 0, 0, 0, 255);

    /* forgatott koordináták számolása */
    for (int i = 0; i &lt; MERET * MERET; ++i) {
        Pont p1 = pontok[i];
        Pont p2 = { p1.x * cos(fy) - p1.z * sin(fy), p1.y, p1.x * sin(fy) + p1.z * cos(fy) };
        Pont p3 = { p2.x, p2.y * cos(fx) - p2.z * sin(fx), p2.y * sin(fx) + p2.z * cos(fx) };
        pontok[i].xf = p3.x;
        pontok[i].yf = p3.y;
        pontok[i].zf = p3.z;
        pontok[i].xk = ABLAK_SZ / 2 + 600 * pontok[i].xf / (pontok[i].zf + 600);
        pontok[i].yk = ABLAK_M / 2 - 600 * pontok[i].yf / (pontok[i].zf + 600);
    }
    /* rendezés és kirajzolás */
    qsort(negyszogek, (MERET - 1) * (MERET - 1), sizeof(negyszogek[0]), negyzetrendez);
    for (int i = 0; i &lt; (MERET - 1) * (MERET - 1); ++i)
        negyzet_rajzol(negyszogek[i]);

    SDL_RenderPresent(renderer);
}</code></pre>

<p>Az összes pont forgatásával a négyszögek „automatikusan” forognak, hiszen a négyszögek
maguk nem tárolnak koordinátákat, hanem csak hivatkoznak a pontokra. Így most is megúszunk
egy csomó számítást, mivel egy pont négy négyszöghöz is tartozik. A felesleges számításokat
pedig jobb kerülni, mert itt már tényleg olyan dolgot csinálunk, amit nem a gép központi
processzorával kellene csináltatni, hanem a grafikus kártyával. Nem véletlen a <code>qsort()</code>
választása. A szélsőértékkereséses vagy a buborékrendezés erre már alkalmatlan. (Ezt is kipróbálhatja
mindenki: a gyorsrendezést a programban egy szélsőértékkereséses rendezésre cserélve
használhatatlanul lassúvá válik az egész.) Ez nagyon fontos, mert egy 256×256-os térkép azt jelenti,
hogy kb. 65000 négyszögünk van. Ha O(n<sup>2</sup>/2) időben futó rendezést használunk, az
kb. 2 milliárd összehasonlítást jelent! Ha O(n×logn) időben futót, az csak 1 milliót. (Ezt
is érdemes kipróbálni! Az összehasonlító függvénybe kell tenni egy sort, amely egy globális
változót megnövel eggyel. A <code>qsort()</code> hívás előtt lenullázva azt a változót, ellenőrizhető,
hogy hányszor hívódott az összehasonlító függvény.)

<p>Az adatszerkezetet a <code>hegy_general()</code> építi föl:

<pre   ><code class="language-c">/* uj hegyet general. ehhez keszit egy uj terkepet, es abbol kiindulva
 * meghatarozza a magassagokat */
void hegy_general(Pont *pontok, Negyszog *negyszogek, SDL_Color pal[]) {
    /* itt most ilyen furcsan foglalodik a 2d tomb, egyszerre. */
    /* csak azert kell igy, mert ha tul nagy, nem fer a verembe! */
    Magassag *k = (Magassag *) malloc(sizeof(Magassag));

    terkep_general(*k);

    for (int y = 0; y &lt; MERET; ++y)
        for (int x = 0; x &lt; MERET; ++x) {
            int i = y*MERET + x;
            pontok[i].x = 500 * (x / (double)MERET - 0.5);
            pontok[i].y = 128 * ((*k)[y][x]) - 32;
            pontok[i].z = 500 * (y / (double)MERET - 0.5);
        }
    for (int y = 0; y &lt; MERET-1; ++y)
        for (int x = 0; x &lt; MERET-1; ++x) {
            int i = y*(MERET-1) + x;
            int c = (magassag(*k, x, y) + frand()/32)*127+128;
            if (c &lt; 0) c = 0;
            if (c &gt; 255) c = 255;
            negyszogek[i].sarkok[0] = &amp;pontok[y*MERET+x];
            negyszogek[i].sarkok[1] = &amp;pontok[y*MERET+x+1];
            negyszogek[i].sarkok[2] = &amp;pontok[(y+1)*MERET+x+1];
            negyszogek[i].sarkok[3] = &amp;pontok[(y+1)*MERET+x];
            negyszogek[i].szin = pal[c].r&lt;&lt;24 | pal[c].g&lt;&lt;16 | pal[c].b&lt;&lt;8 | 0xFF;
        }
}</code></pre>

<p>Ez a pontok <code>x</code> (vízszintes) és <code>z</code> (távolság) koordinátáit a rácspontok
szerint határozza meg, <code>y</code> (függőleges) koordinátáját pedig a kapott hegy magasságai
szerint. A négyszögek csúcsait pedig a szomszédos pontokra állítja be (<code>x</code> és <code>x+1</code>,
illetve <code>y</code> és <code>y+1</code>), figyelve arra a sorfolytonosra lapított kétdimenziós
tömbnél, hogy míg a pontok tömbje <code>MERET</code> széles, a négyzeteké csak <code>MERET-1</code>
szélességű. A négyszög színét is a magasság határozza meg – egy kis véletlenszámot még hozzáad,
egyszerűen csak azért, mert így szebb lesz a rajz. (A tavaknál ez kicsit bekavar – szorgalmi
feladat kijavítani.)

<p>A kész program letölthető innen: <a href="advent19-hegy.c">advent19-hegy.c</a>. A hegyet
forgatni a nyilakkal lehet, új domborzati térképet generálni pedig a szóközzel. Aki meg szeretné
izzasztani a gépét, kipróbálhatja, hogy néz ki egy 256 pont (<code>MERET = 1&lt;&lt;8</code>) által meghatározott hegy,
vagy egy 512 (<code>MERET = 1&lt;&lt;9</code>) által meghatározott.

<p>A program módosított változata, az <a href="advent19-trip.c">advent19-trip.c</a> 
varázsszőnyeget rajzol ki. Aztán hamarosan majd a levegő is fog hullámozni – de arra még egy 
kicsit rá kell pihenni. Holnap játék!
  
    </div>

<div class="clear"></div>

</div>
</section>

</div>
</main>

<footer role="contentinfo">
<div class="shaper">
<div class="footer ">
  <a href="../index/index.html"><img src="../modulz/logo.png" class="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon">
            <a href="../index/index.html">főoldal</a>
         ·     <a href="../elerhetoseg/index.html">elérhetőség</a>
         ·     <a href="../elerhetoseg/index.html#licenc">licenc</a>
         ·     <a href="https://www.facebook.com/infoceetbmehu">facebook</a>
    </div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2021.</div>
</div>
</footer>

</div>

<nav>
<a id="scrolltotop"></a>
</nav>

</body>

</html>
