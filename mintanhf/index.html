<!DOCTYPE html>
<html lang="hu">

<head>
<meta charset="utf-8">
<title>TEST InfoC :: Minta nagy házi</title>
<meta property="og:title" content="TEST InfoC :: Minta nagy házi">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="A minta nagy házi, amely egy plágiumkereső program. Pontosított specifikáció, végleges program és dokumentációja.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="A minta nagy házi, amely egy plágiumkereső program. Pontosított specifikáció, végleges program és dokumentációja.">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<link rel="stylesheet" href="../modulz/alap-infoc.css@v101.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v101.css">
<script>var infoc = { onloads: [] };</script>
<script src="../modulz/site.js@v101"></script>
</head>

<body class=" doksi-formatum" data-version="101"
    data-halozati-hiba="Hálózati hiba a kérés teljesítése közben."
    data-tul-nagy-keres="A fájl túl nagy!"
    data-biztos-navigal="Biztos el szeretnél navigálni? A nem mentett változások elvesznek."
    data-ird-be-a-keresoszot="Írd be a keresőszót!"
    data-vissza="Vissza">

<div class="bodycontent">

<nav class="menubg clearfix">
<div class="shaper">
<div id="menu" class="menu menu-font-size">
<a id="menu-nyito" class="menu-nyito"  role="button"><i class="hamburger"></i></a>
<div class="menu-brand"><a href="../index/index.html">InfoC</a></div>
<div id="menu-elemek" class="menu-elemek">
<ul>
<li class="almenu "><a>Infó</a>
<ul>
<li><a  href="../index/index.html">Kezdőlap</a>
<li><a  href="../elerhetoseg/index.html">Elérhetőség</a>
</ul>

<li class="almenu "><a>Tananyag</a>
<ul>
<li class="almenu "><a>Előadás</a>
<ul>
<li><a  href="../ea01/index.html">1. hét: típusok, változók, vezérlés</a>
<li><a  href="../ea02/index.html">2. hét: nevezetes algoritmusok, tömbök</a>
<li><a  href="../ea03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../ea04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../ea05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../ea06/index.html">6. hét: operátorok, számábrázolás</a>
<li><a  href="../ea07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../ea08/index.html">8. hét: fájlkezelés, modulok</a>
<li><a  href="../ea10/index.html">10. hét: láncolt listák</a>
<li><a  href="../ea11/index.html">11. hét: bináris fák</a>
<li><a  href="../ea12/index.html">12. hét: állapotgépek, reguláris kifejezések</a>
<li><a  href="../ea13/index.html">13. hét: generikus algoritmusok, visszalépő keresés</a>
<li><a  href="../ea14/index.html">14. hét: összefoglalás</a>
</ul>

<li class="almenu "><a>Labor</a>
<ul>
<li><a  href="../lab01/index.html">1. hét: parancssor, ZIP</a>
<li><a  href="../lab02/index.html">2. hét: egyszerű programok</a>
<li><a  href="../lab03/index.html">3. hét: tömbök, nevezetes algoritmusok</a>
<li><a  href="../lab04/index.html">4. hét: struktúrák és függvények</a>
<li><a  href="../lab06/index.html">6. hét: pointerek, sztringek</a>
<li><a  href="../lab07/index.html">7. hét: rekurzió</a>
<li><a  href="../lab08/index.html">8. hét: dinamikus tömbök I.</a>
<li><a  href="../lab09/index.html">9. hét: dinamikus tömbök II.</a>
<li><a  href="../lab10/index.html">10. hét: láncolt listák</a>
<li><a  href="../lab11/index.html">11. hét: bináris fák</a>
<li><a  href="../lab12/index.html">12. hét: gyakorlás NZH-ra</a>
<li><a  href="../lab13/index.html">13. hét: állapotgépek</a>
<li><a  href="../lab14/index.html">14. hét: labirintus játék</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../gy01/index.html">1. hét: adatmodellezés, algoritmusok</a>
<li><a  href="../gy02/index.html">2. hét: tanult algoritmusok</a>
<li><a  href="../gy03/index.html">3. hét: egyszerű programok</a>
<li><a  href="../gy04/index.html">4. hét: tételek és tömbök</a>
<li><a  href="../gy05/index.html">5. hét: származtatott típusok</a>
<li><a  href="../gy06/index.html">6. hét: karakterek, számrendszerek</a>
<li><a  href="../gy07/index.html">7. hét: pointerek használata</a>
<li><a  href="../gy08/index.html">8. hét: rekurzió</a>
<li><a  href="../gy09/index.html">9. hét: dinamikus tömbök</a>
<li><a  href="../gy10/index.html">10. hét: láncolt listák</a>
<li><a  href="../gy12/index.html">12. hét: bináris fák</a>
<li><a  href="../gy13/index.html">13. hét: állapotgépek</a>
<li><a  href="../gy14/index.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="almenu "><a>Példatár</a>
<ul>
<li><a  href="../f01/index.html">1. hét: egyszerű programok</a>
<li><a  href="../f02/index.html">2. hét: logika, sorozatok, tömbök</a>
<li><a  href="../f03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../f04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../f05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../f06/index.html">6. hét: számábrázolás, bitek</a>
<li><a  href="../f07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../f08/index.html">8. hét: parancssor, fájlkezelés, modulok</a>
<li><a  href="../f10/index.html">10. hét: láncolt listák</a>
<li><a  href="../f11/index.html">11. hét: bináris fák, többszörös indirekció</a>
<li><a  href="../f12/index.html">12. hét: állapotgépek</a>
<li><a  href="../f13/index.html">13. hét: generikus algoritmusok</a>
</ul>

<li><a  href="../nhflista/index.html">Nagy házi lista</a>
</ul>

<li class="almenu "><a>Segédlet</a>
<ul>
<li><a  href="../jegyzet/index.html">Jegyzet és puska</a>
<li><a  href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a  href="../stilus/index.html">Kódolási stílus</a>
<li><a  href="../for_vs_while/index.html">For vagy while?</a>
<li class="almenu "><a>Nagy házi</a>
<ul>
<li><a  href="index.html">Minta nagy házi</a>
<li><a  href="../nhfspecifikacio/index.html">Specifikáció: hogyan?</a>
<li><a  href="../debugmalloc/index.html">Debugmalloc, memóriakezelés</a>
<li><a  href="../fajlkezeles/index.html">Fájlkezelés, mappák</a>
<li><a  href="../megjelenites/index.html">Szöveges és grafikus megjelenítés</a>
<li><a  href="../scanf/index.html">Scanf problémák</a>
<li><a  href="../scanf_hibakezeles/index.html">Scanf és hibakezelés</a>
<li><a  href="../karakterkodolas/index.html">Karakterkódolások</a>
<li><a  href="../cbtobbmodul/index.html">Több modulos programok</a>
</ul>

<li class="almenu "><a>ZH</a>
<ul>
<li><a  href="../tldr1/index.html">TL;DR I.</a>
<li><a  href="../tldr2/index.html">TL;DR II.</a>
</ul>

</ul>

<li class="almenu "><a>Extrák</a>
<ul>
<li class="almenu "><a>SVG óra galéria</a>
<ul>
<li><a  href="../orak2021/index.html">SVG óra galéria 2021</a>
<li><a  href="../orak2020/index.html">SVG óra galéria 2020</a>
<li><a  href="../orak2019/index.html">SVG óra galéria 2019</a>
<li><a  href="../orak2018/index.html">SVG óra galéria 2018</a>
<li><a  href="../orak2017/index.html">SVG óra galéria 2017</a>
<li><a  href="../orak2016/index.html">SVG óra galéria 2016</a>
<li><a  href="../orak2015/index.html">SVG óra galéria 2015</a>
</ul>

<li class="almenu "><a>NHF galéria</a>
<ul>
<li><a  href="../nhfgaleria2021/index.html">NHF galéria 2021</a>
<li><a  href="../nhfgaleria2020/index.html">NHF galéria 2020</a>
<li><a  href="../nhfgaleria2019/index.html">NHF galéria 2019</a>
<li><a  href="../nhfgaleria2018/index.html">NHF galéria 2018</a>
<li><a  href="../nhfgaleria2017/index.html">NHF galéria 2017</a>
<li><a  href="../nhfgaleria2016/index.html">NHF galéria 2016</a>
<li><a  href="../nhfgaleria2015/index.html">NHF galéria 2015</a>
<li><a  href="../nhfgaleria2014/index.html">NHF galéria 2014</a>
<li><a  href="../nhfgaleria2013/index.html">NHF galéria 2013</a>
<li><a  href="../nhfgaleria2012/index.html">NHF galéria 2012</a>
</ul>

<li class="almenu "><a>Elmélet</a>
<ul>
<li><a  href="../turing/index.html">Mit tud a számítógép?</a>
<li><a  href="../bf/index.html">BF</a>
<li><a  href="../bitturmix/index.html">Bitturmix</a>
<li><a  href="../kifesto/index.html">Zárt terület kifestése</a>
<li><a  href="../labirintus/index.html">Labirintusok</a>
<li><a  href="../qsort/index.html">Gyorsrendezés</a>
<li><a  href="../tripla/index.html">Tripla indirekció</a>
<li><a  href="../generikus/index.html">Generikus lista</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../strlcpy/index.html">Kulturált sztringmásoló</a>
<li><a  href="../xor_csere/index.html">XOR csere</a>
<li><a  href="../include/index.html">include</a>
<li><a  href="../inline/index.html">inline</a>
<li><a  href="../internet/index.html">Internet</a>
</ul>

<li class="almenu "><a>Grafika</a>
<ul>
<li><a  href="../sdl/index.html">SDL grafika</a>
<li><a  href="../sdl_telepito/index.html">SDL telepítés</a>
<li><a  href="../fa/index.html">Fák rajzolása</a>
</ul>

<li class="almenu "><a>Nyelvészet</a>
<ul>
<li><a  href="../mondatelemzo/index.html">Mondatelemző</a>
<li><a  href="../kifejezesek/index.html">Kifejezések</a>
<li><a  href="../derivalas/index.html">Deriválás</a>
</ul>

<li><a  href="../advent/index.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</div>
</nav>

<div class="menu-font-size"><div class="menuplaceholder"></div></div>

<main class="doksi">
<div class="shaper">


<section class="slidescreen" data-title="Minta nagy házi">
<div class="slide" id="slide_0">

<a id="0" class="namer"></a>


<div class="slidecontent">
  <h1 class="eloadascim">Minta nagy házi</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán · <i class="ido"></i> 2019.10.27.</p>
<p class="kivonat">A minta nagy házi, amely egy plágiumkereső program. Pontosított specifikáció, végleges program és dokumentációja.</p>
</div>

<p>Ez az oldal egy nagy házi nehézségű feladat megoldását tartalmazza. Ehhez hasonlóan kell 
kinézzen a nagy házi megoldása és a hozzá tartozó dokumentáció.</p>




  
        <nav id="tartalom">
      <h3>Tartalom</h3>
      <ol>              <li><a href="index.html#1" class="">NHF 1. – Feladatkiírás</a>
              <li><a href="index.html#2" class="">NHF 2. – Pontosított specifikáció</a>
              <li><a href="index.html#3" class="">NHF 4. részfeladat – Programozói dokumentáció</a>
              <li><a href="index.html#4" class="">NHF 4. részfeladat – Felhasználói dokumentáció</a>
              <li><a href="index.html#5" class="">NHF 4. részfeladat – Forráskód</a>
            </ol>    </nav>
  </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="NHF 1. – Feladatkiírás">
<div class="slide" id="slide_1">

<a id="1" class="namer"></a>
  <a id="mintanhf1" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">1</span><span class="oldalszamafter">. </span>    NHF 1. – Feladatkiírás<a class="hlink" href="index.html#1"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<blockquote>
<p>Valahogy így nézhet ki az a kezdeti feladatkiírás, amely a honlapról származik vagy egy 
hozott feladat. Ez az, amit a feladat kiválasztásaként elfogad a laborvezető – ha a listából
választott a feladat, elég akár a címe is.</p>
</blockquote>

<p>Készíts programot, amely plágium detektálására használható! Olvasson be a program 
szövegfájlokat, és keresse meg közülük azokat a párokat, amelyek leginkább hasonlítanak 
egymásra! A programot parancssori felületről lehessen vezérelni, és meg lehessen neki adni azt 
is, hogy melyik szövegnek ki a szerzője. A kimenetben a hasonlóságok szerzőnév szerint 
szerepeljenek. Találj ki valamilyen módszert, amellyel a hasonlóság vizsgálható!</p>





  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="NHF 2. – Pontosított specifikáció">
<div class="slide" id="slide_2">

<a id="2" class="namer"></a>
  <a id="mintanhf2" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">2</span><span class="oldalszamafter">. </span>    NHF 2. – Pontosított specifikáció<a class="hlink" href="index.html#2"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<blockquote>
<p>A pontosított specifikáció részletesen bemutatja azt, hogy <em>mit</em> fog 
tudni a program: milyen bemenetekkel rendelkezik, milyen kimeneteket állít elő, hogyan kell majd 
kezelni. Ebbe beletartozik a program által kezelt fájlok leírása is.</p>

<p>A specifikáció egy önálló, önmagában értelmezhető szöveg kell legyen. Ez azt jelenti,
hogy a készülő program lényegét, feladatát részletesen el kell magyarázni, akkor is,
ha közismert feladatról van szó. Nem elég annyit írni, hogy egy römi kártyajáték lesz, mert mindenki
máshogy játssza azt: kell dobni vagy nem? mennyi legyen az elsőként lerakott sorok pontértéke
minimálisan? van joker vagy nincs? kell-e dobni vagy nem? és így tovább.</p>

<p>A pontosított specifikáció olyan írásmű, amelyet az iparban a program megrendelője és a 
programozó közösen állítanak össze. A megrendelőt azonban általában nem érdekli, hogyan működik 
a program; sőt ha nem ért a programozáshoz, akkor nem is érti a program belső felépítését. A 
specifikáció ezért semmiképp nem annak leírása, hogy <em>hogyan</em> fog működni a program – az 
már a megvalósítás része!</p>

<p>Ennek az írásnak nem kell pont ugyanígy kinéznie, ugyanilyen felépítéssel rendelkeznie, mint az
itt bemutatottnak. A plágiumkereső egy nem interaktív program (azaz indítása után már nem
vezérelhető, hanem kiszámolja, amit kell, és befejeződik), tehát logikus a specifikációban
arra helyezni a nagy hangsúlyt, hogy milyen bemenő adatokból milyen kimenő adatokat állít
elő. Egy játéknál a pontosított specifikáció inkább a szabályokat rögzítené, és azt mutatná
be, nagyjából hogyan fog kinézni a program: miket lehet választani a menüből, hogyan fog kinézni
játék közben a pálya, mely gombokkal lehet irányítani a játékost stb.</p>

<p>Beadni egy PDF fájlt kell, amely az alábbihoz hasonló tartalmú.</p>
</blockquote>

<h3>A program célja</h3>

<p>A feladat egy olyan program készítése, amely szövegfájlok (dolgozatok) között hasonlóakat 
keres. (Az összehasonlítás módszerét a program fejlesztése során ki kell majd találni.) Az összehasonlítás
eredménye minden szövegpárra egy százalékos mutató, amelynek annál magasabbnak kell lennie, minél
jobban hasonlít egymásra a két szöveg. Az összehasonlított szövegeket hasonlóság szerint sorba
rendezve könnyen felfedezhető a plágium.</p>

<h3>A program használata</h3>

<p>A felhasználónak a program használatához össze kell gyűjtenie az összehasonlítandó szövegeket
(.txt fájlok formájában), továbbá írnia kell egy vezérlőfájlt. A vezérlőfájl mutatja meg
a program számára, hogy melyik fájlokban találja meg az összehasonlítandó szövegeket, és hogy
melyik szövegnek ki a szerzője. Ezeket a vezérlőfájl soronként, szóközzel elválasztva
tartalmazza:</p>

<pre>fájlnév szerző_neve</pre>

<p>A fájlnévben nem lehet szóköz, mert a szerző névtől egy szóköz választja el.
Az utóbbi azonban több tagból is állhat. Pl.:</p>
<pre>
148.txt Csizma Dia
56.txt Olajos Alajos
</pre>

<p>Az így hivatkozott szövegfájlok tetszőleges folyó szöveget tartalmazhatnak. A program
minden indításával egy vezérlőfájlt tud feldolgozni. Indításkor a vezérlőfájlt
(és esetleg egy táblázatfájl nevét) parancssori paraméterként kell megadni a programnak:</p>

<pre>
plagium &lt;vezérlőfájl&gt; [táblázatfájl]
</pre>

<p>A második paraméter nem kötelező – ha adott, akkor abba kerül az Excel által is 
olvasható táblázat, amúgy pedig csak a szabványos kimenetre az első húsz hasonlóság adata.</p>

<h3>A futás eredménye</h3>

<p>A program az összehasonlított dolgozatokat csökkenő hasonlóság szerint listázza a szabványos 
kimenetére. A hasonlóságot százalékban adja meg, ahol 100% a teljesen egyforma dolgozatokat 
jelenti, 0% pedig a teljesen különbözőeket. A kimenet két formátumban jelenik meg. A
szabványos kimeneten az első húsz legnagyobb hasonlóság adata jelenik meg, gyors 
áttekintést adva a futási eredményről. A formátum:</p>

<pre>
név (fájlnév) ↔ név (fájlnév), százalék%
Remek Elek (32.txt) ↔ Csizma Dia (148.txt), 64.58%</pre>

<p>A másik kimenet fájlba íródik, és lényegében ugyanezek az adatok szerepelnek, de az összes 
dolgozatpárra. Az egyes mezőket pontosvessző választja el:</p>

<pre>
százalék;név1;fájlnév1;név2;fájlnév2
64.58;Remek Elek;32.txt;Csizma Dia;148.txt
</pre>

<p>Egy ilyen formátumú fájlt bármelyik táblázatkezelő program meg tud nyitni.</p>





  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="NHF 4. részfeladat – Programozói dokumentáció">
<div class="slide" id="slide_3">

<a id="3" class="namer"></a>
  <a id="mintanhf4dp" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">3</span><span class="oldalszamafter">. </span>    NHF 4. részfeladat – Programozói dokumentáció<a class="hlink" href="index.html#3"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<blockquote>
<p>A programozói dokumentáció célja az, hogy a program belső felépítését, működését
bemutassa. A jó programozói dokumentáció egyik fő ismérve az, hogy azt elolvasva
egy másik programozó hamar képet kap a program felépítéséről, és segítségével
könnyen eligazodik az addig számára ismeretlen forráskódban. Ennek megfelelően
legalább az alábbi részeket kell tartalmazza:</p>

<ul>
    <li>A megvalósított módszerek áttekintő magyarázata. Jelen esetben ez azt a nem triviális
        eljárást mutatja be, amellyel a program összehasonlít két szöveget.
    <li>A program adatszerkezeteinek magyarázata: milyen adat hol tárolódik, és
        miért.
    <li>A program moduljainak és függvényeinek magyarázata: forrásfájlok, függvények;
        mi az egyes modulok és függvények feladata, és hogyan kell azokat használni.
</ul>

<p>Beadni egy PDF fájlt kell, amely az alábbihoz hasonló tartalmú. A felhasználói és a programozó
dokumentáció leadható egy közös PDF-ben, de tartalmilag különállóknak kell lenniük.</p>
</blockquote>

<h3>A dolgozatok összehasonlítása</h3>

<p>A plagizált szövegek leggyakrabban úgy keletkeznek, hogy a plágiumot elkövető szerző egy kiinduló 
szöveget több-kevesebb helyen <em>átfogalmaz.</em> A szöveg értelme meg kell maradjon, ezért a 
változtatás tagmondatok, szövegrészek cseréjéből, továbbá különböző töltelékszavak és szinonímák 
beillesztéséből áll.</p>

<p>A szövegek egyes szavait vizsgálva általában nem vonhatunk le automatikusan következtetést a 
plágiumra. Például bármelyik programozói dokumentáció jogosan tartalmazhatja a „ciklus”, „tömb”, 
„algoritmus” szavakat, ettől azok még teljesen különböző szövegek lehetnek. Azonban a két-, 
három- vagy többszavas sorozatok (kifejezések) egyezése plágiumra utalhat.</p>

<pre class="float">
A program
program módszerének
módszerének lényege
lényege az
az hogy
hogy a
a beolvasott
</pre>

<p>A megírt program módszerének lényege az, hogy a beolvasott dolgozatokat szavakra bontja, és a 
szövegek <em>szópárjait</em> próbálja megtalálni a másik szövegekben. A szópárok vizsgálata 
azért elegendő, mert egy hármas szókapcsolat két egyező szópárként is felfogható, négyes 
kapcsolatok három párként, és így tovább.</p>

<p>A program számára egy szöveg <em>szópárok halmazaként</em> jelenik meg. Egy összehasonlítás a 
<em>halmazok metszését</em> jelenti. Minél nagyobb a metszet halmaz a szöveg teljes 
terjedelméhez képest, annál erősebb a plágium gyanúja.</p>

<p>Az így definiált hasonlóság érdekessége, hogy nem szimmetrikus. Tegyük fel, hogy „A” 
dolgozat teljes egészében tartalmazza „B” dolgozatot, csak a végén szerepel még egy összefoglaló 
rész is. Ebben az esetben „B”-re azt mondhatjuk, hogy a benne lévő szöveg 100%-ban megtalálható 
„A”-ban, az „A” dolgozat szövege viszont nem 100%-ban „B”-ből származik. Ezért két hasonlóságot 
kell meghatározni minden szövegpárhoz. A program kiszámolja mindkét értéket, és a kettő 
maximumát veszi figyelembe.</p>

<p class="megjegyzes">Csak a teljesség kedvéért: ez hasonló az ún.
<a href="https://en.wikipedia.org/wiki/Jaccard_index">Jaccard-féle hasonlósági</a> mértékhez.
Lásd még: <a href="https://en.wikipedia.org/wiki/Overlap_coefficient">átfedési együttható</a>.</p>


<h3>Adatszerkezetek választása</h3>

<p>A program működésének két fő szereplője van. Egyik szereplő a <em>dolgozat,</em> amelynek 
tulajdonságai a szerző neve, a szövegfájl neve és a kifejezések halmaza. Másik szereplő pedig a 
<em>hasonlóság,</em> amely két dolgozatot köt össze: azt tárolja, hogy a két hivatkozott 
dolgozat milyen arányban hasonlít egymásra. Ezeket az adatokat a programnak tárolnia kell, 
amihez adatszerkezetet kell választani.</p>

<p>A dolgozatok egy egyszerű, rendezetlen láncolt listában tárolhatóak, 
amelyben nincsenek strázsa elemek sem. A láncolt lista a vezérlőfájl beolvasásakor könnyen 
bővíthető. Rendezettséget ebben nem szükséges fenntartani, mert az eredményeket nem a dolgozatok 
adatai, hanem a hasonlóságok alapján kell megjeleníteni. Egy dolgozat adatait tároló struktúra:</p>

<pre   ><code class="language-c">typedef struct Dolgozat {
    char fajlnev[33];
    char nev[45];
    Halmaz *kifejezesek;

    struct Dolgozat *kov;   /* láncolt listához */
} Dolgozat;</code></pre>

<p>A hasonlóságok egy dinamikus tömbben tárolhatóak. A meghatározásuk már 
azután történik, hogy az összes dolgozatot beolvastuk, és addigra azok száma ismert. N dolgozat 
esetén N×(N-1)/2 hasonlóságot kell tárolni, mivel mindegyik dolgozatot össze kell hasonlítani 
minden másikkal. A tömböt végül rendezni kell majd a hasonlóság szerint, de ez is csak akkor fog 
történni, amikor már az összes párt megvizsgálta a program, vagyis csak egyetlen egyszer, a 
futás végén. A hasonlóságot tároló struktúra tartalmaz két pointert is, amely alapján visszafelé 
is követhető, melyik dolgozatokra vonatkozik:</p>

<pre   ><code class="language-c">typedef struct Hasonlosag {
    Dolgozat *d1, *d2;
    double has;
} Hasonlosag;</code></pre>

<p>Mivel minden dolgozatot össze kell hasonlítani az összes többivel, és eközben két halmaz 
metszetét kell képezni, a futás sebességét erősen befolyásolja az, hogy a halmazhoz 
milyen adatszerkezetet használunk. A halmaz reprezentációja a következő adatszerkezetekkel 
történhet:</p>

<table>
    <thead>
        <tr><th>reprezentáció<th>beszúrás<th>eleme-e?<th>metszet
    </thead>

    <tr><td>rendezetlen lista<td>Θ(n)<td>Θ(n)<td>Θ(n<sup>2</sup>)
    <tr><td>bináris fa<td>Θ(log&nbsp;n)<td>Θ(log n)<td>Θ(n×log n)
    <tr><td>rendezett lista<td>Θ(n/2)<td>Θ(n/2)<td>Θ(n)
</table>

<p>Rendezetlen lista használata esetén a metszet képzésénél az összehasonlítás lépésszáma Θ(n<sup>2</sup>)
(ahol n a listák hossza), mivel az egyik halmaz minden eleménél meg kell vizsgálnunk, szerepel-e az a 
másik halmazban. A bináris fával reprezentált halmazok esetén ez Θ(n×log&nbsp;n) lépésre redukálódik, 
mivel egy adott elemről Θ(log&nbsp;n) lépésben meg tudjuk mondani, hogy szerepel-e a fában, de ezt 
még mindig meg kell tennünk az összes vizsgálandó elem esetén. A rendezett listán mindez Θ(n)
lépésből elvégezhető az összefésülés algoritmusát használva. Bár az „eleme-e?” művelet és a 
beszúrás is lassabb a bináris fáénál, mégis érdemes ezt választani. A beszúrás műveletét csak a 
dolgozatok beolvasásakor használjuk (dolgozatonként annyiszor, ahány szót tartalmaz a szöveg), a 
metszet képzését viszont dolgozatpáronként el kell végezni. A konkrét „eleme-e?” 
műveletre egyáltalán nincs is szükségünk a programban. Ebből következően a szavak halmazához egy 
rendezett láncolt lista adatszerkezetet kell választani:</p>

<pre   ><code class="language-c">typedef struct Halmaz {
    char szo[2*SZOHOSSZ+1];
    struct Halmaz *kov;   /* láncolt listához */
} Halmaz;</code></pre>

<p>A szó hossza, azaz a sztring maximális mérete a programban fix, ahhoz nem használunk dinamikus tömböt.</p>

<h3>A program működését vezérlő fő függvények</h3>

<dl>
    <dt><code>bool vezerlofajl_beolvas(char *vezerlofajl, Dolgozat **pdolgozatok)</code></dt>
        <dd>Beolvassa a vezérlőfájlt, és létrehozza a dolgozatok listáját. Első paramétere
        a vezérlőfájl neve, második paramétere pedig egy pointer cím szerint, amely
        a lista elejét fogja tartalmazni.
        Igaz értékkel tér vissza, ha rendben volt a vezérlőfájl, egyébként pedig
        hamissal. (Hamis visszatérési érték esetén a visszaadott lista hiányos, de nem
        tartalmaz érvénytelen pointereket.)
        A dolgozatok szövegét a függvény nem olvassa be.
        </dd>
    <dt><code>bool dolgozatok_beolvas(Dolgozat *dolgozatok)</code></dt>
        <dd>Beolvassa a szövegeket, és felépíti a halmazokat. A paramétere a lista, amely
        a dolgozatokat tartalmazza, és benne a fájlok neveit is. A függvény a
        lista láncolását nem módosítja, hanem
        a halmazok jönnek létre minden listaelemben. Igaz értékkel tér vissza, ha
        rendben volt az összes fájl beolvasása, amúgy hamissal. (Hamis visszatérési
        érték esetén csak a dolgozatok egy része tartalmazza a beolvasott szavakat.)
        </dd>
</dl>





<h3>A <code>Dolgozat</code> típus lényeges függvényei és szerepük</h3>

<p>A <code>Dolgozat</code> objektumokból láncolt lista építhető. A <code>NULL</code>
pointer megfelel egy üres dolgozat listának.</p>

<dl>
    <dt><code>Dolgozat *uj_dolgozat(char *fajlnev, char *nev)</code></dt>
        <dd>Ez a függvény létrehoz egy dinamikusan foglalt dolgozatot, üres
        halmazzal.</dd>
    <dt><code>void dolgozatok_felszabadit(Dolgozat *dolgozatok)</code></dt>
        <dd>Felszabadítja a dolgozatokból álló listát (és a hozzájuk tartozó halmazokat is).</dd>
    <dt><code>int dolgozatok_meret(Dolgozat* dolgozatok)</code></dt>
        <dd>Megszámolja a dolgozatokat tartalmazó lista hosszát, és visszatér vele.</dd>
</dl>






<h3>A <code>Halmaz</code> típus függvényei és használatuk</h3>

<p>A <code>Halmaz</code> struktúra a láncolt listákhoz hasonlóan használható:
egy pointert kell hozzá létrehozni. Az üres halmazt a <code>NULL</code>
pointer reprezentálja.</p>

<dl>
    <dt><code>void halmaz_betesz(Halmaz **phalmaz, char *szo)</code></dt>
        <dd>Betesz egy szót a halmazba (ha nincs még benne). Módosíthatja a
        mutatót, ezért cím szerint veszi át.</dd>
    <dt><code>int halmaz_metszet_meret(Halmaz *h1, Halmaz *h2)</code></dt>
        <dd>Megadja két halmaz metszetének méretét.</dd>
    <dt><code>int halmaz_meret(Halmaz *h)</code></dt>
        <dd>Megadja a halmaz méretét.</dd>
    <dt><code>void halmaz_felszabadit(Halmaz *h)</code></dt>
        <dd>Felszabadítja a halmazt.</dd>
</dl>



<h3>A <code>Hasonlosag</code> típus függvényei</h3>

<p>A <code>Hasonlosag</code> típus két dolgozatot hivatkozik meg, és tárolja azok egymáshoz
hasonlóságának mértékét is.</p>

<dl>
    <dt><code>Hasonlosag *hasonlit_osszes(Dolgozat *dolgozatok, int *phas_db)</code></dt>
        <dd>Páronként összehasonlítja az összes szöveget, és előállítja a hasonlóság adatokat.
        Bemenő adata a dolgozatok listája, a kimenő adat pedig a feltöltött hasonlóság tömb.
        A visszaadott tömb mérete n×(n-1)/2 lesz, ahol n a dolgozatok lista hossza.
        Ezt a hívónak majd fel kell szabadítania. A kényelem kedvéért a tömb méretét is
        visszaadja egy cím szerint átvett változóban.</dd>
    <dt><code>Hasonlosag hasonlit(Dolgozat *d1, Dolgozat *d2)</code></dt>
        <dd>Két dolgozatot hasonlít össze (d1, d2). Az ebből keletkező <code>Hasonlosag</code>
        objektummal tér vissza, amelyben minden mezőt kitölt.</dd>
    <dt><code>int osszkep_szerint(void const *egyik, void const *masik)</code></dt>
        <dd>Strcmp-szerű összehasonlító függvény, amely a <code>qsort()</code>-tal használható.
        Csökkenő hasonlóság szerint rendezhető vele sorba egy hasonlóság adatokat tartalmazó tömb.</dd>
</dl>


<h3>A halmazok előállítása, a halmaz metszése és az elemszám használata</h3>

<p>A program működésének leglényegesebb részei a kifejezések halmazának előállítása, a 
halmazok metszése, és az elemszámok viszonyítása a halmazok teljes méretéhez. 
Ezekhez a program az alábbi algoritmusokat alkalmazza.</p>

<pre   ><code class="language-c">/* DOLGOZAT BEOLVASÁSA */
char szo[SZOHOSSZ], elozoszo[SZOHOSSZ] = &quot;&quot;;

while (szot_beolvas(fp, szo)) {
    char kifejezes[2 * SZOHOSSZ + 1];

    /* kifejezés = előző szó + mostani szó */
    strcpy(kifejezes, elozoszo);
    strcat(kifejezes, szo);
    halmaz_betesz(&amp;iter-&gt;kifejezesek, kifejezes);

    /* következő iterációhoz */
    strcpy(elozoszo, szo);
}</code></pre>

<p>A fenti programrész a <code>dolgozatok_beolvas()</code> függvény része. Ez a beolvasás közben 
mindig emlékszik az előző beolvasott szóra. Azt és az aktuálisan beolvasott szót 
összefűzi a <code>kifejezes</code> nevű sztringbe, és az kerül a halmazba. Szóközt nem 
tesz a szavak közé, hiszen a halmaz nem kell értelmes kifejezéseket tartalmazzon, elég ha 
egyforma sztringek keletkeznek. Az összefűzés miatt a kifejezés hossza maximum kétszer akkora 
lehet, mint egy önálló szó hossza – ezért tartalmaz a <code>Halmaz</code> struktúra is a 
szóhossz duplája méretű sztringet.</p>

<pre   ><code class="language-c">/* KÉT HALMAZ METSZETÉNEK ELEMSZÁMA */
int halmaz_metszet_meret(Halmaz *h1, Halmaz *h2) {
    int db = 0;

    /* ha bármelyik null, nincs több összehasonlítandó */
    while (h1 != NULL &amp;&amp; h2 != NULL) {
        int er = strcmp(h1-&gt;szo, h2-&gt;szo);

        if (er &lt; 0)      /* h1 kisebb - az a pointer lép */
            h1 = h1-&gt;kov;
        else if (er &gt; 0) /* h2 kisebb - akkor az */
            h2 = h2-&gt;kov;
        else {           /* ha az elején egyformák, akkor +1 db */
            db++;
            h1 = h1-&gt;kov;
            h2 = h2-&gt;kov;
        }
    }
    return db;
}</code></pre>

<p>Ez a függvény adja meg két halmaz metszetének elemszámát. Az algoritmus
működése kifejezetten arra épül, hogy a halmazok rendezett listában tárolódnak.
A <code>h1</code> és <code>h2</code> pointereket (amelyek lokális változói
a függvénynek), végiglépteti a listákon:</p>
<ul>
    <li>A ciklus addig fut, amíg valamelyik pointer <code>NULL</code> nem lesz.
        Ha bármelyik <code>NULL</code> lett, akkor nem lesz több egyező elem.
    <li>
        <pre class="float">h1 &rarr; 1 3 4 6 7<br>h2 &rarr; 3 4 5 6 8</pre>
        Ha a <code>h1</code> lista elején kisebb elem van, mint <code>h2</code> elején, akkor <code>h1</code>
        pointert léptetni lehet. Ilyenkor <code>h2</code> listában az az elem biztosan nem
        szerepel. Ha szerepelne, akkor az az éppen látott, nagyobb elem előtt
        kellene legyen a listában.
        Jobb oldalt látható erre egy példa. A <code>h1</code> pointer az 1-esre mutat, <code>h2</code> a 3-asra. Ha a <code>h2</code>
        listában lenne 1-es, akkor az a 3-as előtt kellene legyen – ezért biztos,
        hogy nem szerepel abban, és az 1-est ki lehet hagyni <code>h1</code> léptetése által.
        
    <li>Ugyanez a helyzet fordított esetben.
    <li>Végül pedig, ha a listák elején két egyforma elem van, akkor az része a metszetnek
        is. Ilyenkor a darabszámot növelni kell eggyel, és mindkét pointert léptetni
        a listák következő elemeire.
</ul>

<pre   ><code class="language-c">/* DOLGOZATOK HASONLÍTÁSA */
static Hasonlosag hasonlit(Dolgozat *d1, Dolgozat *d2)
{
    Hasonlosag h;
    h.d1 = d1;
    h.d2 = d2;
    
    /* két hasonlóság közül a nagyobbik, azaz a kisebbik méretével osztjuk el. */
    int metszet = halmaz_metszet_meret(d1-&gt;kifejezesek, d2-&gt;kifejezesek);
    int kisebb = min(halmaz_meret(d1-&gt;kifejezesek), halmaz_meret(d2-&gt;kifejezesek));
    h.has = metszet / (double) kisebb;

    return h;
}</code></pre>

<p>Ez a függvény számítja ki a fentiek alapján a szövegek hasonlóságát.
Mivel a halmazműveletek adottak, már csak egy egyszerű osztásról van
szó (amelyben figyelni kell, hogy ne egész osztást végezzünk).








  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="NHF 4. részfeladat – Felhasználói dokumentáció">
<div class="slide" id="slide_4">

<a id="4" class="namer"></a>
  <a id="mintanhf4df" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">4</span><span class="oldalszamafter">. </span>    NHF 4. részfeladat – Felhasználói dokumentáció<a class="hlink" href="index.html#4"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<blockquote>
<p>A felhasználói dokumentáció, ahogy a neve is mutatja, már nem programozóknak
szól, hanem azoknak, akik a programot használni fogják. Itt kell bemutatni azt,
hogy mit tud a program, és hogy hogyan kell az egyes funkcióit aktiválni és használni.</p>

<p>Beadni egy PDF fájlt kell, amely az alábbihoz hasonló tartalmú. A felhasználói és a programozó
dokumentáció leadható egy közös PDF-ben, de tartalmilag különállóknak kell lenniük.</p>
</blockquote>

<p>A <code>plagium</code> program arra való, hogy szöveges fájlok közt megkeressük az egymáshoz 
hasonlókat. Az összehasonlítás azon alapszik, hogy a beolvasott szövegekben szereplő kétszavas 
kifejezéseket hasonlítja össze páronként az összes szövegben. Az összehasonlítások után az egyes 
szövegpárokat a program csökkenő hasonlóság szerinti sorba rendezi, és a szabványos kimeneten 
megjeleníti a legerősebben hasonlító párokat. Az összes hasonlóság adata egy olyan fájlba is 
kiíratható, amelyben a mezőket pontosvessző választja el, és így az táblázatkezelővel (pl. 
Excel) megnyitható.</p>

<p>A program parancsorból indítható:</p>
<pre>plagium &lt;vezérlőfájl&gt; [kimenet.csv]</pre>
<p>Az első paramétere egy vezérlőfájlt ad meg, amely az összehasonlítandó szövegfájlok neveit, 
és azok szerzőinek neveit tartalmazza. A második paraméter opcionális; ha az szerepel, akkor a 
megadott nevű fájlba írja az összehasonlítások adatait.</p>

<p>A vezérlőfájl formátuma a következő kell legyen:</p>

<pre>fájlnév szerző neve</pre>

<p>A fájlnévben nem lehet szóköz, a névtől viszont egy szóköz választja el. A szerző neve 
több szóból is állhat. Pl.:</p>

<pre>
148.txt Csizma Dia
56.txt Olajos Alajos
</pre>

<p>A képernyőn megjelenő kimenet a legnagyobb hasonlóságokat mutatja az alábbi formátumban:</p>

<pre>Remek Elek (32.txt) ↔ Csizma Dia (148.txt), 64.58%</pre>

<p>A kiírt eredményfájl formátuma egy példával:</p>
<pre>
százalék;név1;fájlnév1;név2;fájlnév2
64.58;Remek Elek;32.txt;Csizma Dia;148.txt
</pre>




  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="NHF 4. részfeladat – Forráskód">
<div class="slide" id="slide_5">

<a id="5" class="namer"></a>
  <a id="mintanhf4kod" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">5</span><span class="oldalszamafter">. </span>    NHF 4. részfeladat – Forráskód<a class="hlink" href="index.html#5"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>A program teljes forráskódja és a tesztadatok letölthetőek innen:
<a href="mintanhf.zip">mintanhf.zip</a>.</p>

<p>A program felépítését mutatja az alábbi ábra. Ilyet nem kell készíteni a háziban.
Csak segít eligazodni a programban, ha valaki szeretne elmélyedni ebben a példa kódban.
Kattintásra nagyobb rajz jön elő.</p>

<a href="hivasi_graf.svg"><img src="hivasi_graf.svg" class="kozep"></a>
  
    </div>

<div class="clear"></div>

</div>
</section>

</div>
</main>

<footer role="contentinfo">
<div class="shaper">
<div class="footer ">
  <a href="../index/index.html"><img src="../modulz/logo.png" class="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon">
            <a href="../index/index.html">főoldal</a>
         ·     <a href="../elerhetoseg/index.html">elérhetőség</a>
         ·     <a href="../elerhetoseg/index.html#licenc">licenc</a>
         ·     <a href="https://www.facebook.com/infoceetbmehu">facebook</a>
    </div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2021.</div>
</div>
</footer>

</div>

<nav>
<a id="scrolltotop"></a>
</nav>

</body>

</html>
