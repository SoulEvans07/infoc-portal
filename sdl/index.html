<!DOCTYPE html>
<html lang="hu">

<head>
<meta charset="utf-8">
<title>TEST InfoC :: Az SDL multimédiás könyvtár</title>
<meta property="og:title" content="TEST InfoC :: Az SDL multimédiás könyvtár">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="Grafikus programozás az SDL multimédiás könyvtárral.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="Grafikus programozás az SDL multimédiás könyvtárral.">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<link rel="stylesheet" href="../modulz/alap-infoc.css@v101.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v101.css">
<script>var infoc = { onloads: [] };</script>
<script src="../modulz/site.js@v101"></script>
</head>

<body class=" doksi-formatum" data-version="101"
    data-halozati-hiba="Hálózati hiba a kérés teljesítése közben."
    data-tul-nagy-keres="A fájl túl nagy!"
    data-biztos-navigal="Biztos el szeretnél navigálni? A nem mentett változások elvesznek."
    data-ird-be-a-keresoszot="Írd be a keresőszót!"
    data-vissza="Vissza">

<div class="bodycontent">

<nav class="menubg clearfix">
<div class="shaper">
<div id="menu" class="menu menu-font-size">
<a id="menu-nyito" class="menu-nyito"  role="button"><i class="hamburger"></i></a>
<div class="menu-brand"><a href="../index/index.html">InfoC</a></div>
<div id="menu-elemek" class="menu-elemek">
<ul>
<li class="almenu "><a>Infó</a>
<ul>
<li><a  href="../index/index.html">Kezdőlap</a>
<li><a  href="../elerhetoseg/index.html">Elérhetőség</a>
</ul>

<li class="almenu "><a>Tananyag</a>
<ul>
<li class="almenu "><a>Előadás</a>
<ul>
<li><a  href="../ea01/index.html">1. hét: típusok, változók, vezérlés</a>
<li><a  href="../ea02/index.html">2. hét: nevezetes algoritmusok, tömbök</a>
<li><a  href="../ea03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../ea04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../ea05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../ea06/index.html">6. hét: operátorok, számábrázolás</a>
<li><a  href="../ea07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../ea08/index.html">8. hét: fájlkezelés, modulok</a>
<li><a  href="../ea10/index.html">10. hét: láncolt listák</a>
<li><a  href="../ea11/index.html">11. hét: bináris fák</a>
<li><a  href="../ea12/index.html">12. hét: állapotgépek, reguláris kifejezések</a>
<li><a  href="../ea13/index.html">13. hét: generikus algoritmusok, visszalépő keresés</a>
<li><a  href="../ea14/index.html">14. hét: összefoglalás</a>
</ul>

<li class="almenu "><a>Labor</a>
<ul>
<li><a  href="../lab01/index.html">1. hét: parancssor, ZIP</a>
<li><a  href="../lab02/index.html">2. hét: egyszerű programok</a>
<li><a  href="../lab03/index.html">3. hét: tömbök, nevezetes algoritmusok</a>
<li><a  href="../lab04/index.html">4. hét: struktúrák és függvények</a>
<li><a  href="../lab06/index.html">6. hét: pointerek, sztringek</a>
<li><a  href="../lab07/index.html">7. hét: rekurzió</a>
<li><a  href="../lab08/index.html">8. hét: dinamikus tömbök I.</a>
<li><a  href="../lab09/index.html">9. hét: dinamikus tömbök II.</a>
<li><a  href="../lab10/index.html">10. hét: láncolt listák</a>
<li><a  href="../lab11/index.html">11. hét: bináris fák</a>
<li><a  href="../lab12/index.html">12. hét: gyakorlás NZH-ra</a>
<li><a  href="../lab13/index.html">13. hét: állapotgépek</a>
<li><a  href="../lab14/index.html">14. hét: labirintus játék</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../gy01/index.html">1. hét: adatmodellezés, algoritmusok</a>
<li><a  href="../gy02/index.html">2. hét: tanult algoritmusok</a>
<li><a  href="../gy03/index.html">3. hét: egyszerű programok</a>
<li><a  href="../gy04/index.html">4. hét: tételek és tömbök</a>
<li><a  href="../gy05/index.html">5. hét: származtatott típusok</a>
<li><a  href="../gy06/index.html">6. hét: karakterek, számrendszerek</a>
<li><a  href="../gy07/index.html">7. hét: pointerek használata</a>
<li><a  href="../gy08/index.html">8. hét: rekurzió</a>
<li><a  href="../gy09/index.html">9. hét: dinamikus tömbök</a>
<li><a  href="../gy10/index.html">10. hét: láncolt listák</a>
<li><a  href="../gy12/index.html">12. hét: bináris fák</a>
<li><a  href="../gy13/index.html">13. hét: állapotgépek</a>
<li><a  href="../gy14/index.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="almenu "><a>Példatár</a>
<ul>
<li><a  href="../f01/index.html">1. hét: egyszerű programok</a>
<li><a  href="../f02/index.html">2. hét: logika, sorozatok, tömbök</a>
<li><a  href="../f03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../f04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../f05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../f06/index.html">6. hét: számábrázolás, bitek</a>
<li><a  href="../f07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../f08/index.html">8. hét: parancssor, fájlkezelés, modulok</a>
<li><a  href="../f10/index.html">10. hét: láncolt listák</a>
<li><a  href="../f11/index.html">11. hét: bináris fák, többszörös indirekció</a>
<li><a  href="../f12/index.html">12. hét: állapotgépek</a>
<li><a  href="../f13/index.html">13. hét: generikus algoritmusok</a>
</ul>

<li><a  href="../nhflista/index.html">Nagy házi lista</a>
</ul>

<li class="almenu "><a>Segédlet</a>
<ul>
<li><a  href="../jegyzet/index.html">Jegyzet és puska</a>
<li><a  href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a  href="../stilus/index.html">Kódolási stílus</a>
<li><a  href="../for_vs_while/index.html">For vagy while?</a>
<li class="almenu "><a>Nagy házi</a>
<ul>
<li><a  href="../mintanhf/index.html">Minta nagy házi</a>
<li><a  href="../nhfspecifikacio/index.html">Specifikáció: hogyan?</a>
<li><a  href="../debugmalloc/index.html">Debugmalloc, memóriakezelés</a>
<li><a  href="../fajlkezeles/index.html">Fájlkezelés, mappák</a>
<li><a  href="../megjelenites/index.html">Szöveges és grafikus megjelenítés</a>
<li><a  href="../scanf/index.html">Scanf problémák</a>
<li><a  href="../scanf_hibakezeles/index.html">Scanf és hibakezelés</a>
<li><a  href="../karakterkodolas/index.html">Karakterkódolások</a>
<li><a  href="../cbtobbmodul/index.html">Több modulos programok</a>
</ul>

<li class="almenu "><a>ZH</a>
<ul>
<li><a  href="../tldr1/index.html">TL;DR I.</a>
<li><a  href="../tldr2/index.html">TL;DR II.</a>
</ul>

</ul>

<li class="almenu "><a>Extrák</a>
<ul>
<li class="almenu "><a>SVG óra galéria</a>
<ul>
<li><a  href="../orak2021/index.html">SVG óra galéria 2021</a>
<li><a  href="../orak2020/index.html">SVG óra galéria 2020</a>
<li><a  href="../orak2019/index.html">SVG óra galéria 2019</a>
<li><a  href="../orak2018/index.html">SVG óra galéria 2018</a>
<li><a  href="../orak2017/index.html">SVG óra galéria 2017</a>
<li><a  href="../orak2016/index.html">SVG óra galéria 2016</a>
<li><a  href="../orak2015/index.html">SVG óra galéria 2015</a>
</ul>

<li class="almenu "><a>NHF galéria</a>
<ul>
<li><a  href="../nhfgaleria2021/index.html">NHF galéria 2021</a>
<li><a  href="../nhfgaleria2020/index.html">NHF galéria 2020</a>
<li><a  href="../nhfgaleria2019/index.html">NHF galéria 2019</a>
<li><a  href="../nhfgaleria2018/index.html">NHF galéria 2018</a>
<li><a  href="../nhfgaleria2017/index.html">NHF galéria 2017</a>
<li><a  href="../nhfgaleria2016/index.html">NHF galéria 2016</a>
<li><a  href="../nhfgaleria2015/index.html">NHF galéria 2015</a>
<li><a  href="../nhfgaleria2014/index.html">NHF galéria 2014</a>
<li><a  href="../nhfgaleria2013/index.html">NHF galéria 2013</a>
<li><a  href="../nhfgaleria2012/index.html">NHF galéria 2012</a>
</ul>

<li class="almenu "><a>Elmélet</a>
<ul>
<li><a  href="../turing/index.html">Mit tud a számítógép?</a>
<li><a  href="../bf/index.html">BF</a>
<li><a  href="../bitturmix/index.html">Bitturmix</a>
<li><a  href="../kifesto/index.html">Zárt terület kifestése</a>
<li><a  href="../labirintus/index.html">Labirintusok</a>
<li><a  href="../qsort/index.html">Gyorsrendezés</a>
<li><a  href="../tripla/index.html">Tripla indirekció</a>
<li><a  href="../generikus/index.html">Generikus lista</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../strlcpy/index.html">Kulturált sztringmásoló</a>
<li><a  href="../xor_csere/index.html">XOR csere</a>
<li><a  href="../include/index.html">include</a>
<li><a  href="../inline/index.html">inline</a>
<li><a  href="../internet/index.html">Internet</a>
</ul>

<li class="almenu "><a>Grafika</a>
<ul>
<li><a  href="index.html">SDL grafika</a>
<li><a  href="../sdl_telepito/index.html">SDL telepítés</a>
<li><a  href="../fa/index.html">Fák rajzolása</a>
</ul>

<li class="almenu "><a>Nyelvészet</a>
<ul>
<li><a  href="../mondatelemzo/index.html">Mondatelemző</a>
<li><a  href="../kifejezesek/index.html">Kifejezések</a>
<li><a  href="../derivalas/index.html">Deriválás</a>
</ul>

<li><a  href="../advent/index.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</div>
</nav>

<div class="menu-font-size"><div class="menuplaceholder"></div></div>

<main class="doksi">
<div class="shaper">


<section class="slidescreen" data-title="Az SDL multimédiás könyvtár">
<div class="slide" id="slide_0">

<a id="0" class="namer"></a>


<div class="slidecontent">
  <h1 class="eloadascim">Az SDL multimédiás könyvtár</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán, Dobos-Kovács Mihály, Lant Gábor · <i class="ido"></i> 2019.10.27.</p>
<p class="kivonat">Grafikus programozás az SDL multimédiás könyvtárral.</p>
</div>

<img class="float" src="sdl.png">

<p>Az SDL egy <em>platformfüggetlen multimédiás függvénykönyvtár</em>. A programozók számára egy 
egységes felületet biztosít a grafikus megjelenítéshez, hangok megszólaltatásához, billentyűk, 
egér és botkormányok kezeléséhez, miközben az egyes géptípusok, operációs rendszerek 
különbségeit elfedi. Így az SDL-lel megírt program működik különféle Windows verziókon, de 
Linuxokon, Mac OS X-en, és még néhány okostelefonon is.</p>

<p>Az alap SDL-ben nincsenek vonal, kör, és egyéb primitívek kirajzolásához függvények. Ahhoz 
további könyvtárakat kell telepíteni (pl. SDL_gfx). Ezen függvénykönyvtárak tudása viszont már 
elég nagy. Az SDL_ttf segítségével bármilyen betűtípust használva rajzolhatunk, az SDL_mixer 
több hang és zene megszólaltatását teszi lehetővé, az SDL_net pedig a hálózatprogramozás 
ügyes-bajos dolgait rejti egy platformfüggetlen réteg mögé. Az SDL_image nevű kiegészítő sokféle 
képformátumot (PNG, JPG) ismer; ilyen fájlokat lehet vele betölteni, és a programban kirajzolni.
</p>

<p>Ez az írás tartalmaz néhány olyan információt (pl. a többmodulos programokkal kapcsolatban), 
amelyek csak egy későbbi előadás után lesznek teljesen érthetőek. De addig is használhatóak az 
instrukciókat pontosan követve. Az <em>SDL telepítéséről</em> egy <a href="../sdl_telepito/index.html">külön írásban</a> olvashattok.</p>





  
        <nav id="tartalom">
      <h3>Tartalom</h3>
      <ol>              <li><a href="index.html#1" class="">Az első program</a>
              <li><a href="index.html#2" class="">Események, eseményvezérelt programozás</a>
              <li><a href="index.html#3" class="">Az időzítők használata</a>
              <li><a href="index.html#4" class="">Képfájlok beolvasása</a>
              <li><a href="index.html#5" class="">Szövegek megjelenítése</a>
              <li><a href="index.html#6" class="">A billentyűzet kezelése</a>
              <li><a href="index.html#7" class="">Szöveg bevitele</a>
              <li><a href="index.html#8" class="">Többmodulos projektek és az SDL-es programok futtatása</a>
              <li><a href="index.html#9" class="">MacOS Mojave problémák</a>
            </ol>    </nav>
  </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Az első program">
<div class="slide" id="slide_1">

<a id="1" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">1</span><span class="oldalszamafter">. </span>    Az első program<a class="hlink" href="index.html#1"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<img src="sdl-korok.png" class="float" alt="SDL: grafikus primitívek">

<p>Alább látható az első program. Ez kirajzol néhány kört a képernyőre, utána pedig
addig vár, amíg a felhasználó be nem zárja az ablakot a nagy piros X-szel.</p>

<p>Az első lépés az SDL könyvtár inicializálása, ezt az <code>SDL_Init()</code>
nevű függvénnyel tehetjük meg. Az SDL alrendszerekből áll (grafika, hang, időzítés
stb.), legegyszerűbb azt mondani, hogy inicializáljuk mindegyiket
(<code>SDL_INIT_EVERYTHING</code>).</p>

<p>Ezután létrehozunk egy 440×360 képpont méretű ablakot az 
<code>SDL_CreateWindow()</code> hívással. Ennek meg kell adni az ablak 
pozícióját és méretét; az utolsó paraméterében pedig a tulajdonságait 
(átméretezhető-e stb.), ez most egyszerűen <code>0</code>. A 
visszatérési értéket eltároljuk az <code>SDL_Window *window</code> 
változóba, így tudunk majd az ablakra hivatkozni – amúgy lehetne több 
is.</p>

<p>A harmadik lépés egy megjelenítő (renderer) létrehozása az ablakhoz. 
Ez végzi majd a rajzolást az ablakba. Azért kell ezt külön lépésként 
kezelni, mert a megjelenítést végezheti a program is (szoftveres), vagy 
a grafikus kártya adta lehetőségeket közvetlenül is kihasználhatnánk 
(hardveres megjelenítés). Erről itt részletesen nem lesz szó, hanem
csak a 4. féléves Számítógépes grafika tárgyban. A Prog1 példaprogramjai
mindenhol szoftveres megjelenítést (<code>SDL_RENDERER_SOFTWARE</code>)
használnak majd, mert azt könnyebb kezelni.</p>

<p>Ez a függvény is adhat <code>NULL</code> pointert, ami azt jelenti, 
hogy valami probléma történt. Ha nem, akkor viszont indulhat a 
rajzolás!</p>

<pre   ><code class="language-c">#include &lt;SDL.h&gt;
#include &lt;SDL2_gfxPrimitives.h&gt;
#include &lt;math.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[]) {
    /* SDL inicializálása és ablak megnyitása */
    if (SDL_Init(SDL_INIT_EVERYTHING) &lt; 0) {
        SDL_Log(&quot;Nem indithato az SDL: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Window *window = SDL_CreateWindow(&quot;SDL peldaprogram&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 440, 360, 0);
    if (window == NULL) {
        SDL_Log(&quot;Nem hozhato letre az ablak: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE);
    if (renderer == NULL) {
        SDL_Log(&quot;Nem hozhato letre a megjelenito: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_RenderClear(renderer);

    /* rajzok */
    int x, y, r;
    r = 50;

    /* karika */
    x = 100;
    y = 100;
    circleRGBA(renderer, x, y, r, 255, 0, 0, 255);
    circleRGBA(renderer, x + r, y, r, 0, 255, 0, 255);
    circleRGBA(renderer, x + r * cos(3.1415 / 3), y - r * sin(3.1415 / 3), r, 0, 0, 255, 255);

    /* antialias karika */
    x = 280;
    y = 100;
    aacircleRGBA(renderer, x, y, r, 255, 0, 0, 255);
    aacircleRGBA(renderer, x + r, y, r, 0, 255, 0, 255);
    aacircleRGBA(renderer, x + r * cos(3.1415 / 3), y - r * sin(3.1415 / 3), r, 0, 0, 255, 255);

    /* kitoltott kor */
    x = 100;
    y = 280;
    filledCircleRGBA(renderer, x, y, r, 255, 0, 0, 255);
    filledCircleRGBA(renderer, x + r, y, r, 0, 255, 0, 255);
    filledCircleRGBA(renderer, x + r * cos(3.1415 / 3), y - r * sin(3.1415 / 3), r, 0, 0, 255, 255);

    /* attetszo kor */
    x = 280;
    y = 280;
    filledCircleRGBA(renderer, x, y, r, 255, 0, 0, 96);
    filledCircleRGBA(renderer, x + r, y, r, 0, 255, 0, 96);
    filledCircleRGBA(renderer, x + r * cos(3.1415 / 3), y - r * sin(3.1415 / 3), r, 0, 0, 255, 96);

    /* szoveg */
    stringRGBA(renderer, 110, 350, &quot;Kilepeshez: piros x az ablakon&quot;, 255, 255, 255, 255);

    /* az elvegzett rajzolasok a kepernyore */
    SDL_RenderPresent(renderer);

    /* varunk a kilepesre */
    SDL_Event ev;
    while (SDL_WaitEvent(&amp;ev) &amp;&amp; ev.type != SDL_QUIT) {
        /* SDL_RenderPresent(renderer); - MacOS Mojave esetén */
    }

    /* ablak bezarasa */
    SDL_Quit();

    return 0;
}</code></pre>

<div class="megjegyzes">
    <p>A legalsó ciklusban található egy megjegyzés – az egy SDL hiba miatt van, ami macOS Mojave esetén
    jöhet elő. Lásd <a href="index.html#sdlmojavebug">lentebb</a>.</p>
</div>

<p>A program köröket rajzol, négyféleképpen. Az első három körnél egyszerűen kiszínezi
azokat a képpontokat (pixel), amelyek a körívre esnek. A második háromnál ennél okosabb. Ahol
a körív nem pont a képpontra esik, ott a szomszédos képpontok között színátmenetet képez.
Ezt az eljárást úgy nevezik, hogy antialiasing. Így a rajz szebb, a körív nem annyira recegős.</p>

<p>A pozíció és a méret megadása után következik mindegyik függvénynél a szín megadása.
Ezek három komponensből állnak: vörös, zöld és kék, mindegyik 0-tól 255-ig. A 255, 0, 0 jelenti
a vöröset, 255, 255, 255 pedig a teljesen fehéret. A legutolsó paraméter az átlátszatlanságot
adja meg, amely ugyancsak egy 0 és 255 közötti érték. 0 jelenti a teljesen átlátszót, 255
pedig a teljesen átlátszatlant. Ez látszik a jobb alsó sarokban, ahol a köröknél
az érték 255 helyett csak 96. Így azok színei keverednek.</p>

<p>Miután elvégeztük az összes rajzolást, meg kell hívni az <code>SDL_RenderPresent()</code> függvényt,
hogy az elkészült rajzot megjelenítsük. A rajzolások először csak a memóriában történtek, és igazából a hívás hatására
kerül ki minden az ablakba. Ez azért előnyös, mert így a felhasználó nem fogja látni, ahogy
egyesével jelennek meg az elemek, hanem csak a végeredményt – animációnál ez fontos lesz.
A további rajzolásokkal a meglévő képet módosítjuk; az eredmény pedig egy újabb
<code>SDL_RenderPresent()</code> hatására jelenik meg.</p>

<p>Az SDL_gfx függvénykönyvtár néhány rajzeleme (grafikus primitíve):</p>

<ul>
    <li><code>pixelRGBA(kép, x, y, r, g, b, a)</code> – képpont rajzolása.
    <li><code>lineRGBA(kép, x1, y1, x2, y2, r, g, b, a)</code> – szakasz.
    <li><code>thickLineRGBA(kép, x1, y1, x2, y2, v, r, g, b, a)</code> – vastag szakasz.
    <li><code>rectangleRGBA(kép, x1, y1, x2, y2, r, g, b, a)</code> – téglalap.
    <li><code>boxRGBA(kép, x1, y1, x2, y2, r, g, b, a)</code> – kitöltött téglalap.
    <li><code>circleRGBA(kép, x1, y1, R, r, g, b, a)</code> – kör.
    <li><code>trigonRGBA(kép, x1, y1, x2, y2, x3, y3, r, g, b, a)</code> – háromszög.
    <li><code>filledTrigonRGBA(kép, x1, y1, x2, y2, x3, y3, r, g, b, a)</code> – kitöltött háromszög.
    <li><code>stringRGBA(kép, x, y, szöveg, r, g, b, a)</code> – szöveg.
</ul>

<p>A vonalas rajzokat (szakasz, kör, háromszög stb.) készítő függvényeknek mind van <code>aa</code>-val
kezdődő párjuk is. Ezen felül minden függvénynek van egy nem <code>RGBA</code>-ra, 
hanem <code>Color</code>-ra végződő nevű párja: az utóbbiak a négy, színt megadó paraméter 
helyett csak egyetlen egyet várnak. Ez az egyetlen <code>Uint32</code> típusú paraméter <code>
0xRRGGBBAA</code> formában tartalmazza a színkomponenseket és az átlátszóság információt. Tehát 
mind a vörös, zöld, kék komponensnek, mind az átlátszóságnak egyetlen egy bájt jut. Így egy szín 
egyetlen egy változóban is eltárolható. A 32 biten megadott színkód bitműveletekkel állítható 
elő (<code>r&lt;&lt;24 | g&lt;&lt;16 | b&lt;&lt;8 | a</code>). Például az alábbi sorok teljesen 
ekvivalensek, mindegyik félig átlátszó lila kört rajzol:</p>

<pre   ><code class="language-c">filledCircleRGBA(screen, 320, 240, 100, 255, 0, 255, 128);
filledCircleRGBA(screen, 320, 240, 100, 0xFF, 0, 0xFF, 0x80);
filledCircleColor(screen, 320, 240, 100, 0xFF00FF80);</code></pre>

<h3>Dokumentáció</h3>

<ul>
    <li>Az SDL függvényeinek dokumentációja elérhető az <a href="https://wiki.libsdl.org/APIByCategory">SDL Wiki</a> oldalán.</li>
    <li>Az SDL_gfx függvényeről pedig az <a href="http://www.ferzkopp.net/Software/SDL2_gfx/Docs/html/_s_d_l2__gfx_primitives_8h.html">SDL2_gfx</a> oldalán lehet olvasni.</li>
</ul>






  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Események, eseményvezérelt programozás">
<div class="slide" id="slide_2">

<a id="2" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">2</span><span class="oldalszamafter">. </span>    Események, eseményvezérelt programozás<a class="hlink" href="index.html#2"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<img src="sdl-pofa.png" class="float" alt="Események kezelése: egér">

<p>Az egyszerű, konzolos programok lineárisan működnek: a <code>printf()</code>-fel mondhatunk 
valamit a felhasználónak, a <code>scanf()</code>-fel pedig kérdezhetünk tőle valamit. Nem gond 
az, hogy a <code>scanf()</code> megakasztja a programot, mert amíg nincs meg a bemenő adat, addig 
úgysem tudna továbbhaladni a program. Egy játéknál, meg általában a grafikus programoknál ez 
nincs így. A programnak itt egyszerre több bemenete van: a billentyűzetre és az egérre is 
reagálnia kell, arról nem is beszélve, hogy ha a felhasználó épp nem nyúl semelyikhez, akkor is 
folytatódnia kell a képernyőn látható eseményeknek. Nem akadhat meg a játék attól, hogy éppen 
nem nyomtuk meg egyik gombot sem!</p>

<p>Ezért találták ki az <em>eseményvezérelt programozást</em>. Az SDL a programhoz beérkező 
eseményeket összegyűjti (billentyűzet, egérmozdulatok, időzítések, ablak bezárása), és azokat 
keletkezésük sorrendjében adja nekünk. Ezt a programnak egy eseményhurokban (event loop) kell 
feldolgoznia, amely nagyon egyszerű:</p>

<pre   ><code class="language-c">SDL_Event event;

while (fut_a_program) {
    SDL_WaitEvent(&amp;event);  /* várunk a következő eseményre */

    switch (event.type) {   /* esemény típusa szerinti esetszétválasztás */

        ...                 /* esemény feldolgozása */

    }
}</code></pre>

<p>Az <code>SDL_WaitEvent()</code> függvény addig vár, amíg meg nem történik a következő 
esemény; amint az bekövetkezik, akkor az adatait beteszi az <code>event</code> nevű, 
<code>SDL_Event</code> típusú struktúrába (azért veszi át cím szerint, hogy ezt meg tudja 
tenni). A várakozás után az eseményt feldolgozhatjuk, annak típusa szerint:</p>

<ul>
    <li><code>case <a href="https://wiki.libsdl.org/SDL_QuitEvent">SDL_QUIT</a>:</code> kilépés, a felhasználó az ablak bezárása
        ×-re kattintott; <code>break;</code>
    <li><code>case <a href="https://wiki.libsdl.org/SDL_MouseMotionEvent">SDL_MOUSEMOTION</a>:</code> egérmozdulat; <code>break;</code>
    <li><code>case <a href="https://wiki.libsdl.org/SDL_MouseButtonEvent">SDL_MOUSEBUTTONDOWN</a>: case SDL_MOUSEBUTTONUP:</code> egérgomb kattintás és elengedés; <code>break;</code>
    <li><code>case <a href="https://wiki.libsdl.org/SDL_KeyboardEvent">SDL_KEYDOWN</a>: case SDL_KEYUP:</code> billentyűzet események; <code>break;</code>
</ul>

<p>Az <code>event</code> struktúra az esemény típusától függően további információkat tartalmaz. 
Egérmozgás esetén az <a href="https://wiki.libsdl.org/SDL_MouseMotionEvent"><code>event.motion</code></a> 
struktúrát tölti ki az <code>SDL_WaitEvent()</code> a koordinátákkal: <code>event.motion.x</code>
a vízszintes, <code>event.motion.y</code> a függőleges koordináta. Kattintásnál az <a 
href="https://wiki.libsdl.org/SDL_MouseButtonEvent"><code>event.button</code></a> 
struktúra adattagjai vesznek fel értékeket: az <code>event.button.button</code> adattag mutatja, 
hogy melyik gombról van szó <code>SDL_BUTTON_LEFT</code>, <code>SDL_BUTTON_MIDDLE</code>, 
<code>SDL_BUTTON_RIGHT</code>.</p>

<p>Az alábbi C programban rajzolni lehet az egérrel. A működést a kód közepén lévő eseményhurok
irányítja. A bal gombbal lehet rajzolni, a jobb gombbal pedig törölni az ablak tartalmát.
Az eseményvezérlés kellemes vonása, hogy a program gyakorlatilag semennyire sem terheli le
a számítógépet. Amíg nincs esemény, addig ugyanúgy alszik, ahogyan azt egy <code>scanf()</code>-re
várakozás esetén is teszi.</p>

<pre   ><code class="language-c">#include &lt;SDL.h&gt;
#include &lt;SDL2_gfxPrimitives.h&gt;
#include &lt;math.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[]) {
    /* SDL inicializálása és ablak megnyitása */
    if (SDL_Init(SDL_INIT_EVERYTHING) &lt; 0) {
        SDL_Log(&quot;Nem indithato az SDL: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Window *window = SDL_CreateWindow(&quot;SDL peldaprogram&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, 440, 360, 0);
    if (window == NULL) {
        SDL_Log(&quot;Nem hozhato letre az ablak: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE);
    if (renderer == NULL) {
        SDL_Log(&quot;Nem hozhato letre a megjelenito: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_RenderClear(renderer);
    
    /* az esemenyvezerelt hurok */
    bool quit = false;
    bool click = false;
    int elozox = 0;
    int elozoy = 0;
    while (!quit) {
        SDL_Event event;
        SDL_WaitEvent(&amp;event);

        bool rajzoltam = false;

        switch (event.type) {
            /* eger kattintas */
            case SDL_MOUSEBUTTONDOWN:
                if (event.button.button == SDL_BUTTON_LEFT) {
                    click = true;
                    elozox = event.button.x;
                    elozoy = event.button.y;
                }
                else if (event.button.button == SDL_BUTTON_RIGHT) {
                    boxColor(renderer, 0, 0, 439, 359, 0x000000FF);
                    rajzoltam = true;
                }
                break;
            /* egergomb elengedese */
            case SDL_MOUSEBUTTONUP:
                if (event.button.button == SDL_BUTTON_LEFT) {
                    click = false;
                }
                break;
            /* eger mozdulat */
            case SDL_MOUSEMOTION:
                if (click) {
                    aalineColor(renderer, elozox, elozoy,
                                event.motion.x, event.motion.y, 0xFFFFFFFF);
                    rajzoltam = true;
                }
                /* a kovetkezo mozdulat esemenyhez */
                elozox = event.motion.x;
                elozoy = event.motion.y;
                break;
            /* ablak bezarasa */
            case SDL_QUIT:
                quit = true;
                break;
        }

        if (rajzoltam)
            SDL_RenderPresent(renderer);
    }

    SDL_Quit();

    return 0;
}</code></pre>

<p>Maga az eseményhurok ennél a progamnál tulajdonképpen egy állapotgép. Na nem azért, mert 
<code>switch</code> van benne (az csak az események típusának megállapításához kell), hanem 
mert az egyes események jelentése eltérő attól függően, hogy mik történtek a múltban. Például az 
egérmozdulatnál csak akkor rajzolunk, ha előzőleg egy kattintás eseményt már feldolgoztunk. 
Minden mozdulatnál megjegyezzük a koordinátákat, hogy a legközelebbi ugyanilyen eseménynél 
tudjuk, honnan hova kell húzni a vonalat.</p>

<div class="megjegyzes csik">
<h4>SDL_WaitEvent vagy SDL_PollEvent?</h4>
<p>Eseménykezelésre az SDL-ben két függvény is van, a <code>WaitEvent</code> és a <code>PollEvent</code>. A 
kettő között a különbség az, hogy a <code>WaitEvent</code> megvárja, amíg történik valami, és addig nem tér vissza, amíg nincs 
feldolgozandó esemény. A <code>PollEvent</code> azonnal visszatér mindig, akkor is, ha épp nincs teendő. A <code>PollEvent</code> 
függvényt a legritkább esetben használjuk, ciklusban különösen nem, mert 100%-ra járatnánk a gépet. A legtöbbször a 
<code>WaitEvent</code>-re van szükség. Ha a várakozás idejét limitálni kell, akkor időzítőket érdemes használni – lásd a 
következő részt.</p>
</div>



  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Az időzítők használata">
<div class="slide" id="slide_3">

<a id="3" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">3</span><span class="oldalszamafter">. </span>    Az időzítők használata<a class="hlink" href="index.html#3"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<img src="sdl-golyo.png" class="float" alt="Pattogó labda">

<p>Előbb arról volt szó, hogy a program futásának nem szabad megszakadnia amiatt, mert eseményre 
vár – és aztán jött egy program forráskódja, amely nem csinál semmit, azaz alszik az események 
között. Hogy fog akkor a játék tovább futni, amíg a felhasználó nem nyúl se a billentyűzethez, 
se az egérhez? Nagyon egyszerű: létre kell hozni egy időzítőt, amely adott időközönként generál 
egy eseményt. Ha létrejön az esemény, annak hatására fel fog ébredni az eseményhurok – de fel fog 
ébredni a billentyűzet vagy az egér hatására is.</p>

<p>Időzítőt létrehozni az <code>SDL_AddTimer()</code> függvénnyel lehet. Ennek paraméterei a 
következők: 1) mennyi idő múlva hívódjon meg (ezredmásodperc), 2) melyik függvény hívódjon meg, 
3) egy tetszőleges mutató, amit paraméterként meg fog kapni a függvény. (Ha ez nem kell semmire, 
akkor lehet NULL.) A függvény visszatérési értéke egy <code>SDL_TimerID</code> típusú azonosító, 
amivel hivatkozhatunk az időzítőre (pl. az <code>SDL_RemoveTimer()</code>-nek paraméterként adva 
letilthatjuk azt.) A hívás tehát így néz ki:</p>

<pre   ><code class="language-c">id = SDL_AddTimer(20, idozit, NULL);</code></pre>

<p>A paraméterként adott függvény fejléce kötött, ilyen kell legyen:</p>

<pre   ><code class="language-c">Uint32 idozit(Uint32 ms, void *param);</code></pre>

<p>Vagyis az SDL időzítője által meghívott függvény megkapja paraméterként azt, hogy milyen 
időközökre lett beállítva, és a tetszőleges felhasználói paramétert. Visszatérési értéke pedig 
egy egész szám, hogy legközelebb hány ezredmásodperc múlva hívódjon meg. Legegyszerűbb, ha egy 
<code>return ms;</code> sorral fejezzük be a függvényt, amiben általában amúgy sincs más, csak 
egy felhasználói típusú esemény létrehozása, és beillesztése a várakozási sorba:</p>

<pre   ><code class="language-c">Uint32 idozit(Uint32 ms, void *param) {
    SDL_Event ev;
    ev.type = SDL_USEREVENT;
    SDL_PushEvent(&amp;ev);
    return ms;   /* ujabb varakozas */
}</code></pre>

<p>Az eseménykezelő hurkot tehát ki kell egészíteni az SDL_USEREVENT típusú esemény(ünk) 
feldolgozásával. A labdát pattogtató program így néz ki:</p>

<pre   ><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;SDL.h&gt;
#include &lt;SDL2_gfxPrimitives.h&gt;


/* ablak megnyitasa */
void sdl_init(int szeles, int magas, SDL_Window **pwindow, SDL_Renderer **prenderer) {
    if (SDL_Init(SDL_INIT_EVERYTHING) &lt; 0) {
        SDL_Log(&quot;Nem indithato az SDL: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Window *window = SDL_CreateWindow(&quot;SDL peldaprogram&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, szeles, magas, 0);
    if (window == NULL) {
        SDL_Log(&quot;Nem hozhato letre az ablak: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE);
    if (renderer == NULL) {
        SDL_Log(&quot;Nem hozhato letre a megjelenito: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_RenderClear(renderer);

    *pwindow = window;
    *prenderer = renderer;
}


/* ez a fuggveny hivodik meg az idozito altal.
 * betesz a feldolgozando esemenyek koze (push) egy felhasznaloi esemenyt */
Uint32 idozit(Uint32 ms, void *param) {
    SDL_Event ev;
    ev.type = SDL_USEREVENT;
    SDL_PushEvent(&amp;ev);
    return ms;   /* ujabb varakozas */
}


int main(int argc, char *argv[]) {
    enum { ABLAK=360 };
    enum { GOLYO_R=10 };
    typedef struct Golyo {
        int x, y;
        int vx, vy;
    } Golyo;
    
    
    SDL_Window *window;
    SDL_Renderer *renderer;
    sdl_init(ABLAK, ABLAK, &amp;window, &amp;renderer);

    /* idozito hozzaadasa: 20 ms; 1000 ms / 20 ms -&gt; 50 fps */
    SDL_TimerID id = SDL_AddTimer(20, idozit, NULL);

    /* animaciohoz */
    Golyo g;
    g.x = ABLAK/2;
    g.y = ABLAK/3;
    g.vx = 3;
    g.vy = 2;

    /* szokasos esemenyhurok */
    bool quit = false;
    while (!quit) {
        SDL_Event event;
        SDL_WaitEvent(&amp;event);

        switch (event.type) {
            /* felhasznaloi esemeny: ilyeneket general az idozito fuggveny */
            case SDL_USEREVENT:
                /* kitoroljuk az elozo poziciojabol (nagyjabol) */
                filledCircleRGBA(renderer, g.x, g.y, GOLYO_R, 0x20, 0x20, 0x40, 0xFF);
                /* kiszamitjuk az uj helyet */
                g.x += g.vx;
                g.y += g.vy;
                /* visszapattanás */
                if (g.x &lt; GOLYO_R || g.x &gt; ABLAK-GOLYO_R)
                    g.vx *= -1;
                if (g.y &lt; GOLYO_R || g.y &gt; ABLAK-GOLYO_R)
                    g.vy *= -1;
                /* ujra kirajzolas, es mehet a kepernyore */
                filledCircleRGBA(renderer, g.x, g.y, GOLYO_R, 0x80, 0x80, 0xFF, 0xFF);
                SDL_RenderPresent(renderer);
                break;

            case SDL_QUIT:
                quit = true;
                break;
        }
    }
    /* idozito torlese */
    SDL_RemoveTimer(id);

    SDL_Quit();

    return 0;
}</code></pre>

<p>Itt nagyon fontos, hogy csak a kép teljes megrajzolása után hívjuk meg az 
<code>SDL_RenderPresent()</code>-et. Ha a törlés után is meghívnánk, akkor az animáció villódzna 
(flicker), így viszont szép, folytonos a megjelenítés. Törölni viszont kell, hiszen mindig az 
előzőleg megrajzolt képet módosítjuk.</p>

<p>Nem csak egy, hanem akár egyszerre több időzítőt is létrehozhatunk. Hogy ezeket meg lehessen 
különböztetni, az általuk generált eseményeknek érdemes külön azonosítót adni. Az események 
típusa, az <code>event.type</code> adattag nem felsorolt típus, hanem egy egyszerű egész szám. 
Az SDL dokumentációja pedig azt mondja, hogy az <code>SDL_USEREVENT</code> konstanstól (ez egy 
felsorolt típusú érték) fölfelé bármilyen saját eseményt definiálhatunk. Ezért ezeket 
használhatjuk akár úgy is, hogy az egyik időzítőnk <code>SDL_USEREVENT+1</code>, a másik 
<code>SDL_USEREVENT+2</code> stb. típusú eseményeket generál.</p>





  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Képfájlok beolvasása">
<div class="slide" id="slide_4">

<a id="4" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">4</span><span class="oldalszamafter">. </span>    Képfájlok beolvasása<a class="hlink" href="index.html#4"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<img src="sdl-sakk.png" class="float arnyek" alt="Sakktábla" style="width: 20em;">

<p>Ez nagyon egyszerű feladat: az SDL_image nevű függvénykönyvtárnak van egy 
<code>IMG_LoadTexture()</code> nevű függvénye. Ennek paramétere a megjelenítő mellett a <em>betöltendő kép,</em> ami 
elég sokféle formátumú lehet (az SDL_image dokumentációja szerint BMP, GIF, JPEG, LBM, PCX, PNG, 
PNM, TGA, TIFF, WEBP, XCF, XPM és XV). A függvény visszatérési értéke egy 
<code>SDL_Texture*</code>, vagyis egy mutató a betöltött képre. Ezzel tudunk később hivatkozni 
rá, mert bent maradt a gép memóriájában. Ha már nincs rá szükség, <em>fel kell azt 
szabadítani,</em> az <code>SDL_DestroyTexture()</code> függvénnyel. Ha ezt nem tesszük meg, a 
betöltött képek miatt a programunk egyre több memóriát foglal. Úgyhogy ez fontos!</p>

<p>A betöltött képpel sincsen nehéz dolgunk: az <code>SDL_RenderCopy()</code> függvény tud képet megjeleníteni. Ennek a 
paraméterei: megjelenítő, kép, forrás téglalap, cél téglalap. Vagyis nem csak a teljes képet tudja másolni, hanem annak csak egy 
részletét is, a cél kép tetszőleges pozíciójára. A pozíciókat és a méreteket <code>SDL_Rect</code> típusú struktúrákkal kell 
megadni; ezekre a függvény pointereket vesz át:</p>

<pre   ><code class="language-c">SDL_Rect forrasterulet = { forras_x, forras_y, forras_szelesseg, forras_magassag };
SDL_Rect celterulet    = { cel_x, cel_y, cel_szelesseg, cel_magassag };

SDL_BlitSurface(megjelenito, kep, &amp;forrasterulet, &amp;celterulet);</code></pre>

<p>Ha a teljes forrás képet szeretnénk másolni, akkor a forrás téglalapra mutató pointer lehet 
<code>NULL</code>, de a cél méreteit ilyenkor is meg kell adni. Ha le szeretnénk kérdezni egy
betöltött kép méretét, azt a <code>SDL_QueryTexture(source, NULL, NULL, &amp;w, &amp;h);</code>
hívással tehetjük meg.</p>

<img src="pieces.png" class="kozep" alt="Sakk figurák">
<div class="kozep"><a href="pieces.png">pieces.png</a> (jobb klikk a letöltéshez)</div>

<p>Az alábbi programban kihasználjuk azt, hogy a kép egy részét is lehet másolni. A program 
tartalmaz egy felsorolt típust, amely a fenti képen látható figurák sorrendjében nevezi meg 
azokat. A <code>babu_rajzol()</code> függvényen belül kiszámítódnak a fenti képen belüli 
koordináták (melyik figuráról van szó). Ez a kép 
egyébként átlátszó képpontokat is tartalmaz, az SDL ezt is támogatja. A fájlt le kell tölteni, 
és a futtatható (.exe) mellé tenni <code>pieces.png</code> néven.</p>

<p>Néhány fontos dolog:</p>
<ul>
    <li>A betöltött képet, amíg nem dobtuk el az <code>SDL_DestroyTexture()</code> függvénnyel,
        akárhányszor használhatjuk.
    <li>A képeket ide-oda adogathatjuk a programban: az <code>SDL_Texture*</code> típusú képhivatkozás
        akár függvény paramétere vagy visszatérési értéke is lehet.
    <li>Az <code>SDL_RenderCopyEx()</code> függvény forgatni is tud.
    <li>Az SDL_image teljes dokumentációja itt érhető el: <a href="https://www.libsdl.org/projects/SDL_image/docs/">SDL_image</a>.
</ul>


<pre   ><code class="language-c">#include &lt;SDL.h&gt;
#include &lt;SDL_image.h&gt;
#include &lt;SDL2_gfxPrimitives.h&gt;
#include &lt;stdlib.h&gt;


/* mezon allo figura. ugyanolyan sorrendben vannak, mint a kepen,
 * igy a kapott egesz szamok megegyeznek a png-beli indexekkel */
typedef enum Babu {
    VKiraly, VVezer, VBastya, VFuto, VHuszar, VGyalog,
    SKiraly, SVezer, SSastya, SFuto, SHuszar, SGyalog
} Babu;

/* a pieces.png fajlban levo figurak merete */
enum { MERET = 52 };

/* kirajzol egy babut; a forras a betoltott png, a cel nevu kepre rajzol.
 * melyik babut, milyen koordinatakra: melyik, x, y. */
void babu_rajzol(SDL_Renderer *renderer, SDL_Texture *babuk, Babu melyik, int x, int y) {
    /* a forras kepbol ezekrol a koordinatakrol, ilyen meretu reszletet masolunk. */
    SDL_Rect src = { (melyik % 6) * 62 + 10, (melyik / 6) * 60 + 10, MERET, MERET };
    /* a cel kepre, ezekre a koordinatakra masoljuk */
    SDL_Rect dest = { x, y, MERET, MERET };
    /* kepreszlet masolasa */
    SDL_RenderCopy(renderer, babuk, &amp;src, &amp;dest);
}


/* ablak megnyitasa */
void sdl_init(int szeles, int magas, SDL_Window **pwindow, SDL_Renderer **prenderer) {
    if (SDL_Init(SDL_INIT_EVERYTHING) &lt; 0) {
        SDL_Log(&quot;Nem indithato az SDL: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Window *window = SDL_CreateWindow(&quot;SDL peldaprogram&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, szeles, magas, 0);
    if (window == NULL) {
        SDL_Log(&quot;Nem hozhato letre az ablak: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE);
    if (renderer == NULL) {
        SDL_Log(&quot;Nem hozhato letre a megjelenito: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_RenderClear(renderer);

    *pwindow = window;
    *prenderer = renderer;
}


int main(int argc, char *argv[]) {
    SDL_Window *window;
    SDL_Renderer *renderer;
    sdl_init(320, 200, &amp;window, &amp;renderer);

    /* kep betoltese */
    SDL_Texture *babuk = IMG_LoadTexture(renderer, &quot;pieces.png&quot;);
    if (babuk == NULL) {
        SDL_Log(&quot;Nem nyithato meg a kepfajl: %s&quot;, IMG_GetError());
        exit(1);
    }

    /* rajz keszitese */
    boxRGBA(renderer, 0, 0, 319, 199, 0x90, 0xE0, 0x90, 0xFF);
    babu_rajzol(renderer, babuk, VKiraly, 82, 74);
    babu_rajzol(renderer, babuk, SGyalog, 82+MERET, 74);
    babu_rajzol(renderer, babuk, VHuszar, 82+2*MERET, 74);
    SDL_RenderPresent(renderer);

    /* nincs mar ra szukseg: felszabaditjuk a memoriat */
    SDL_DestroyTexture(babuk);

    /* szokasos varakozas */
    SDL_Event event;
    while (SDL_WaitEvent(&amp;event) &amp;&amp; event.type != SDL_QUIT) {
    }

    SDL_Quit();
    return 0;
}</code></pre>





  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Szövegek megjelenítése">
<div class="slide" id="slide_5">

<a id="5" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">5</span><span class="oldalszamafter">. </span>    Szövegek megjelenítése<a class="hlink" href="index.html#5"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>Az SDL_gfx <code>stringRGBA()</code> függvénye meg tud jeleníteni szövegeket (lásd az első 
példaprogramot), de sajnos a használt betűk nagyon kicsik, és nem ismeri a magyar ékezetes 
betűket sem (árvíztűrő tükörfúrógép). SDL_TTF függvénykönyvtár megoldja mindkét problémát. (A 
dokumentációja <a href="http://www.libsdl.org/projects/SDL_ttf/docs/">itt érhető el.</a>) Ez 
tetszőleges True Type betűtípust be tud olvasni (Arial, Trebuchet stb.), és helyesen tudja 
kezelni az ékezetes betűket is.</p>

<p>Bár az angol ábécé betűit kódoló ASCII szabvány gyakorlatilag mára egyeduralkodóvá vált a 
világon, az ékezetes betűket és egyéb karaktereket kódoló szabványokról ez sajnos nem mondható 
el. Több kódtáblát, azaz betű&rarr;szám táblázatot is használnak elterjedten a világon; az 
egységes Unicode kódolás még nem szorította ki a többit. (Ezekről bővebben a <a href="../karakterkodolas/index.html">Rémtörténet a karakterkódolásokról</a> írásban 
olvashatsz.) A többféle kódtábla miatt az SDL_TTF-ben minden szövegrajzoló függvénynek három 
változata van: 1) a Latin-1 kódolású szöveget, 2) a Unicode kódolású szöveget, és 3) az UTF-8 
kódolású szöveget váró függvény.</p>

<p>A használat menete a következő. A használandó betűtípus fájlt először meg kell nyitni az 
<code>TTF_OpenFont()</code> függvényhívással. Ilyenkor meg kell adni a betűk méretét is. A 
függvény visszatérési értéke egy <code>TTF_Font</code> típusú mutató, amellyel hivatkozni lehet 
a betűtípusra (ilyenből több is lehet), és amelyet a <code>TTF_CloseFont()</code> függvénynek a 
program végén oda kell adni, hogy felszabadítsa a memóriaterületet.</p>

<img src="sdl-ttf.png" class="kozep">

<div class="kozep"><a href="liberationserif-regular.ttf">LiberationSerif-Regular.ttf</a> (klikk a letöltéshez)</div>

<p>Minden alkalommal, amikor egy szöveget meg kell rajzolni, azt valamelyik 
<code>TTF_Render&hellip;()</code> függvénnyel kell tenni, függően a 
rajzolás kívánt minőségétől és a karakterkódolástól. A függvények visszatérnek egy 
<code>SDL_Surface*</code> típusú mutatóval, mivel a rajzolások kimenete egy kép, amelyben meg van 
rajzolva a felirat. Ez már átadható a megjelenítőnek, <code>SDL_Texture</code> objektummá
alakítható a <code>SDL_CreateTextureFromSurface()</code> függvénnyel. Ha 
már nincs rá szükség, akkor pedig fel kell szabadítani a hozzá tartozó memóriaterületet az 
<code>SDL_FreeSurface()</code> hívással. (Természetesen ha sok, különféle felirat van, akkor 
ehhez a műveletsorhoz érdemes saját függvényeket írni. A programozásban nem copy-pastelünk!)

<p>A rajzolások módja a következő lehet, bár a kép mindent elmond:</p>
<ul>
    <li><code>TTF_Render..._Solid</code>: gyors, de a betűk széle recegős.
    <li><code>TTF_Render..._Shaded</code>: nem recegős. A háttér egy megadott szín.
    <li><code>TTF_Render..._Blended</code>: nem recegős. A háttér átlátszó.
</ul>

<p>Betűtípusokat a Windows <code>C:\Windows\Fonts</code> mappájában, vagy a Linux
<code>/usr/share/fonts/truetype</code> mappájában lehet találni. Meg a neten egy
csomó helyen, csak sajnos az ingyenes betűtípusokból hiányozni szokott a hosszú <code>ő</code> és az <code>ű</code>
betű. A lenti program a Liberation Serif nevű betűtípust használja. A linkre
kattintva letölthető fájlt a Code::Blocks projekt mappájába kell tenni.</p>

<pre   ><code class="language-c">#include &lt;SDL.h&gt;
#include &lt;SDL_ttf.h&gt;
#include &lt;SDL2_gfxPrimitives.h&gt;
#include &lt;stdlib.h&gt;


void sdl_init(int szeles, int magas, SDL_Window **pwindow, SDL_Renderer **prenderer) {
    if (SDL_Init(SDL_INIT_EVERYTHING) &lt; 0) {
        SDL_Log(&quot;Nem indithato az SDL: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Window *window = SDL_CreateWindow(&quot;SDL peldaprogram&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, szeles, magas, 0);
    if (window == NULL) {
        SDL_Log(&quot;Nem hozhato letre az ablak: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE);
    if (renderer == NULL) {
        SDL_Log(&quot;Nem hozhato letre a megjelenito: %s&quot;, SDL_GetError());
        exit(1);
    }

    *pwindow = window;
    *prenderer = renderer;
}


int main(int argc, char *argv[]) {
    SDL_Window *window;
    SDL_Renderer *renderer;
    sdl_init(480, 200, &amp;window, &amp;renderer);

    SDL_Color feher = {255, 255, 255}, piros = {255, 0, 0};

    /* hatter */
    for (int i = 0; i &lt; 500; ++i)
        filledCircleRGBA(renderer, rand() % 480, rand() % 200,
                         10 + rand() % 5, rand() % 256, rand() % 256, rand() % 256, 64);

    /* betutipus betoltese, 32 pont magassaggal */
    TTF_Init();
    TTF_Font *font = TTF_OpenFont(&quot;LiberationSerif-Regular.ttf&quot;, 32);
    if (!font) {
        SDL_Log(&quot;Nem sikerult megnyitni a fontot! %s\n&quot;, TTF_GetError());
        exit(1);
    }

    /* felirat megrajzolasa, kulonfele verziokban */
    SDL_Surface *felirat;
    SDL_Texture *felirat_t;
    SDL_Rect hova = { 0, 0, 0, 0 };

    /* ha sajat kodban hasznalod, csinalj belole fuggvenyt! */
    felirat = TTF_RenderUTF8_Solid(font, &quot;TTF_RenderUTF8_Solid()&quot;, feher);
    felirat_t = SDL_CreateTextureFromSurface(renderer, felirat);
    hova.x = (480 - felirat-&gt;w) / 2;
    hova.y = 20;
    hova.w = felirat-&gt;w;
    hova.h = felirat-&gt;h;
    SDL_RenderCopy(renderer, felirat_t, NULL, &amp;hova);
    SDL_FreeSurface(felirat);
    SDL_DestroyTexture(felirat_t);

    /* ha sajat kodban hasznalod, csinalj belole fuggvenyt! */
    felirat = TTF_RenderUTF8_Shaded(font, &quot;TTF_RenderUTF8_Shaded()&quot;, feher, piros);
    felirat_t = SDL_CreateTextureFromSurface(renderer, felirat);
    hova.x = (480 - felirat-&gt;w) / 2;
    hova.y = 60;
    hova.w = felirat-&gt;w;
    hova.h = felirat-&gt;h;
    SDL_RenderCopy(renderer, felirat_t, NULL, &amp;hova);
    SDL_FreeSurface(felirat);
    SDL_DestroyTexture(felirat_t);

    /* ha sajat kodban hasznalod, csinalj belole fuggvenyt! */
    felirat = TTF_RenderUTF8_Blended(font, &quot;TTF_RenderUTF8_Blended()&quot;, feher);
    felirat_t = SDL_CreateTextureFromSurface(renderer, felirat);
    hova.x = (480 - felirat-&gt;w) / 2;
    hova.y = 100;
    hova.w = felirat-&gt;w;
    hova.h = felirat-&gt;h;
    SDL_RenderCopy(renderer, felirat_t, NULL, &amp;hova);
    SDL_FreeSurface(felirat);
    SDL_DestroyTexture(felirat_t);

    /* tudja az ekezeteket */
    /* ez az utf8 szoveg azert nez ki ilyen rosszul, mert szinte csak ekezetes betu van benne.
     * amugy a code::blocks-ban utf8 forrasfajlt kell beallitani, es akkor irhato kozvetlenul
     * ekezetes betu ide. */
    felirat = TTF_RenderUTF8_Blended(font, &quot;\xC3\xA1rv\xC3\xADzt\xC5\xB1r\xC5\x91 &quot;
                                           &quot;t\xC3\xBCk\xC3\xB6rf\xC3\xBAr\xC3\xB3g\xC3\xA9p &quot;
                                           &quot;\xE2\x98\xBA \xE2\x82\xAC&quot;, feher);
    felirat_t = SDL_CreateTextureFromSurface(renderer, felirat);
    hova.x = (480 - felirat-&gt;w) / 2;
    hova.y = 140;
    hova.w = felirat-&gt;w;
    hova.h = felirat-&gt;h;
    SDL_RenderCopy(renderer, felirat_t, NULL, &amp;hova);
    SDL_FreeSurface(felirat);
    SDL_DestroyTexture(felirat_t);

    SDL_RenderPresent(renderer);

    /* nem kell tobbe */
    TTF_CloseFont(font);

    SDL_Event event;
    while (SDL_WaitEvent(&amp;event) &amp;&amp; event.type != SDL_QUIT) {
    }

    SDL_Quit();

    return 0;
}</code></pre>

<div class="sticky">Fontos!</div>
<p>A <code>TTF_Init()</code> függvényhívást elég egyszer megtenni a program legelején. A 
<code>TTF_OpenFont()</code> által beolvasott betűtípus pedig akárhányszor használható – annyi 
szöveget írhatunk ki vele, amennyit csak szeretnénk. Akár többféle betűtípus is lehet betöltve 
egyszerre. Ha valamelyikre nincs már szükségünk, csak akkor kell felszabadítani a hozzá tartozó 
memóriaterületet egy <code>TTF_CloseFont()</code> hívással. Ha többször is szeretnénk használni 
a betűtípust, nem szabad mindig törölni és újra betölteni azt, mivel nagyon időigényes az a 
művelet! A betöltött betűtípusokat hivatkozó <code>TTF_Font*</code> típusú mutatók a képekhez 
hasonlóan függvényeknek is átadhatjuk.</p>




  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="A billentyűzet kezelése">
<div class="slide" id="slide_6">

<a id="6" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">6</span><span class="oldalszamafter">. </span>    A billentyűzet kezelése<a class="hlink" href="index.html#6"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>A billentyűzet kezelése SDL-ben nem nagy ördöngősség: <code>SDL_KEYDOWN</code>
eseményt kapunk egy billentyű megnyomásánál, <code>SDL_KEYUP</code> eseményt az
elengedésénél. Az esemény adatait tároló strktúrában az
<a href="https://wiki.libsdl.org/SDL_KeyboardEvent">alábbi adattagok</a> érhetőek el:</p>

<ul>
    <li><code>event.key.keysym.sym</code>: a lenyomott billentyű azonosítója,
    <a href="https://wiki.libsdl.org/SDL_Keycode">ebből</a> a táblázatból.
    <li><code>event.key.keysym.mod</code>: módosító billentyűk (shift, ctrl stb.)
    <a href="https://wiki.libsdl.org/SDL_Keymod">ebből</a> a táblázatból.
    Mivel egyszerre több módosító is le lehet nyomva, egy bitenkénti ÉS <code>&amp;</code>
    művelettel kell megvizsgálni azt, amelyik érdekes. A módosítók lenyomásakor
    külön esemény is érkezik.
</ul>

<p>Játékokban, ahol arra vagyunk kíváncsiak, hogy nyomva van-e tartva egy billentyű, nekünk kell 
külön megjegyezni azt. Ez egyszerűen megoldható egy logikai típusú változóval, amelynek értékét 
<code>SDL_KEYDOWN</code> esemény esetén igazra, <code>SDL_KEYUP</code> esemény esetén pedig 
hamisra állítjuk. Az alábbi példaprogramban pontosan ez történik. A balra <kbd>&larr;</kbd>
és jobbra <kbd>&rarr;</kbd> nyilakat nyomva tartva lehet változtatni a háromszögek színét.
Az <kbd>Esc</kbd> gomb pedig az ablak bezárásához hasonlóan kilép a programból.</p>

<img src="sdl-billentyuzet.png" class="arnyek kozep" alt="billentyűk állapotát mutató program">

<pre   ><code class="language-c">#include &lt;SDL.h&gt;
#include &lt;SDL2_gfxPrimitives.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdlib.h&gt;
 
 
/* ablak megnyitasa */
void sdl_init(int szeles, int magas, SDL_Window **pwindow, SDL_Renderer **prenderer) {
    if (SDL_Init(SDL_INIT_EVERYTHING) &lt; 0) {
        SDL_Log(&quot;Nem indithato az SDL: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Window *window = SDL_CreateWindow(&quot;SDL peldaprogram&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, szeles, magas, 0);
    if (window == NULL) {
        SDL_Log(&quot;Nem hozhato letre az ablak: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE);
    if (renderer == NULL) {
        SDL_Log(&quot;Nem hozhato letre a megjelenito: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_RenderClear(renderer);
    
    *pwindow = window;
    *prenderer = renderer;
}
 
 
int main(int argc, char *argv[]) {
    SDL_Window *window;
    SDL_Renderer *renderer;
    sdl_init(350, 200, &amp;window, &amp;renderer);
 
    bool quit = false;
    bool left = false;
    bool right = false;
    bool rajz = true;
    while (!quit) {
        if (rajz) {
            if (left)
                filledTrigonRGBA(renderer, 50, 100, 150, 50, 150, 150, 0x00, 0xC0, 0x00, 0xFF);
            else
                filledTrigonRGBA(renderer, 50, 100, 150, 50, 150, 150, 0xFF, 0x00, 0x00, 0xFF);
            if (right)
                filledTrigonRGBA(renderer, 300, 100, 200, 50, 200, 150, 0x00, 0xC0, 0x00, 0xFF);
            else
                filledTrigonRGBA(renderer, 300, 100, 200, 50, 200, 150, 0xFF, 0x00, 0x00, 0xFF);
            SDL_RenderPresent(renderer);
            rajz = false;
        }

        SDL_Event event;
        SDL_WaitEvent(&amp;event);
 
        switch (event.type) {
            /* felhasznaloi esemeny: ilyeneket general az idozito fuggveny */
            case SDL_KEYUP:
                switch (event.key.keysym.sym) {
                    case SDLK_LEFT: left = false; rajz = true; break;
                    case SDLK_RIGHT: right = false; rajz = true; break;
                    case SDLK_ESCAPE: quit = true; break;
                }
                break;
                
            case SDL_KEYDOWN:
                switch (event.key.keysym.sym) {
                    case SDLK_LEFT: left = true; rajz = true; break;
                    case SDLK_RIGHT: right = true; rajz = true; break;
                }
                break;
 
            case SDL_QUIT:
                quit = true;
                break;
        }
    }
     
    SDL_Quit();
    return 0;
}</code></pre>





  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Szöveg bevitele">
<div class="slide" id="slide_7">

<a id="7" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">7</span><span class="oldalszamafter">. </span>    Szöveg bevitele<a class="hlink" href="index.html#7"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>A szövegbevitel kezelése nem olyan egyszerű feladat, mint amilyennek hangzik. A szöveg szerkesztését is kezelni kell (pl. 
Backspace gomb), de előfordulhat az is, hogy a szimpla billentyűzetnél bonyolultabb szövegbeviteli eszközt használ a felhasználó. 
Bár a magyar nyelvre ez nem jellemző, távolkeleti nyelveknél a billentyűzet használata mellett felugró ablakból kellhet 
kiválasztani az egyes karaktereket.</p>

<p>Az SDL szerencsére ezeket az eszközöket is kezeli, és a végeredményként előálló szövegdarabokat <code>SDL_TEXTINPUT</code> 
típusú események paramétereiként megkapjuk. A törlést és a bevitelt nyugtázó Entert persze ettől függetlenül nekünk kell 
kezelni.</p>

<p>Az alábbi program egy egyszerű szövegbeviteli mező megvalósítását mutatja. Ha valaki nem szeretne elmélyülni ebben, nem gond,
az <code>input_text()</code> függvényt bátran fel lehet használni saját programokban vagy nagy házi feladatban. A paraméterei:</p>

<ul>
    <li><code>char *dest</code>: ide írja a beolvasott szöveget, <a href="../karakterkodolas/index.html">UTF-8 karakterkódolással</a>.</li>
    <li><code>size_t hossz</code>: maximum ennyi bájt hosszú szöveget olvas be.</li>
    <li><code>SDL_Rect teglalap</code>: a szövegbeviteli mező helyét és méretét megadó téglalap.</li>
    <li><code>SDL_Color hatter</code>: a mező színe.</li>
    <li><code>SDL_Color szoveg</code>: a szöveg színe.</li>
    <li><code>TTF_Font *font</code>: a betűtípus, amellyel rajzol.</li>
    <li><code>SDL_Renderer *renderer</code>: az ablak.</li>
</ul>

<p>Visszatérési értéke azt mondja meg, sikeres volt-e a beolvasás. A példaprogram ezt a betűtípust használja:
<a href="liberationserif-regular.ttf">LiberationSerif-Regular.ttf</a> (klikk a letöltéshez). A függvény csak
szoftveres megjelenítés használata esetén működik helyesen (lásd fent).</p>

<pre   ><code class="language-c">#include &lt;SDL.h&gt;
#include &lt;SDL_ttf.h&gt;
#include &lt;SDL2_gfxPrimitives.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

void sdl_init(int szeles, int magas, const char* tipus, SDL_Window **pwindow, SDL_Renderer **prenderer, TTF_Font **pfont) {
    if (SDL_Init(SDL_INIT_EVERYTHING) &lt; 0) {
        SDL_Log(&quot;Nem indithato az SDL: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Window *window = SDL_CreateWindow(&quot;SDL peldaprogram&quot;, SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED, szeles, magas, 0);
    if (window == NULL) {
        SDL_Log(&quot;Nem hozhato letre az ablak: %s&quot;, SDL_GetError());
        exit(1);
    }
    SDL_Renderer *renderer = SDL_CreateRenderer(window, -1, SDL_RENDERER_SOFTWARE);
    if (renderer == NULL) {
        SDL_Log(&quot;Nem hozhato letre a megjelenito: %s&quot;, SDL_GetError());
        exit(1);
    }

    TTF_Init();
    TTF_Font *font = TTF_OpenFont(tipus, 32);
    if (font == NULL) {
        SDL_Log(&quot;Nem sikerult megnyitni a fontot! %s\n&quot;, TTF_GetError());
        exit(1);
    }

    *pwindow = window;
    *prenderer = renderer;
    *pfont = font;
}

void sdl_close(SDL_Window **pwindow, SDL_Renderer **prenderer, TTF_Font **pfont) {
    SDL_DestroyRenderer(*prenderer);
    *prenderer = NULL;

    SDL_DestroyWindow(*pwindow);
    *pwindow = NULL;

    TTF_CloseFont(*pfont);
    *pfont = NULL;

    SDL_Quit();
}


/* Beolvas egy szoveget a billentyuzetrol.
 * A rajzolashoz hasznalt font es a megjelenito az utolso parameterek.
 * Az elso a tomb, ahova a beolvasott szoveg kerul.
 * A masodik a maximális hossz, ami beolvasható.
 * A visszateresi erteke logikai igaz, ha sikerult a beolvasas. */
bool input_text(char *dest, size_t hossz, SDL_Rect teglalap, SDL_Color hatter, SDL_Color szoveg, TTF_Font *font, SDL_Renderer *renderer) {
    /* Ez tartalmazza az aktualis szerkesztest */
    char composition[SDL_TEXTEDITINGEVENT_TEXT_SIZE];
    composition[0] = '\0';
    /* Ezt a kirajzolas kozben hasznaljuk */
    char textandcomposition[hossz + SDL_TEXTEDITINGEVENT_TEXT_SIZE + 1];
    /* Max hasznalhato szelesseg */
    int maxw = teglalap.w - 2;
    int maxh = teglalap.h - 2;

    dest[0] = '\0';

    bool enter = false;
    bool kilep = false;

    SDL_StartTextInput();
    while (!kilep &amp;&amp; !enter) {
        /* doboz kirajzolasa */
        boxRGBA(renderer, teglalap.x, teglalap.y, teglalap.x + teglalap.w - 1, teglalap.y + teglalap.h - 1, hatter.r, hatter.g, hatter.b, 255);
        rectangleRGBA(renderer, teglalap.x, teglalap.y, teglalap.x + teglalap.w - 1, teglalap.y + teglalap.h - 1, szoveg.r, szoveg.g, szoveg.b, 255);
        /* szoveg kirajzolasa */
        int w;
        strcpy(textandcomposition, dest);
        strcat(textandcomposition, composition);
        if (textandcomposition[0] != '\0') {
            SDL_Surface *felirat = TTF_RenderUTF8_Blended(font, textandcomposition, szoveg);
            SDL_Texture *felirat_t = SDL_CreateTextureFromSurface(renderer, felirat);
            SDL_Rect cel = { teglalap.x, teglalap.y, felirat-&gt;w &lt; maxw ? felirat-&gt;w : maxw, felirat-&gt;h &lt; maxh ? felirat-&gt;h : maxh };
            SDL_RenderCopy(renderer, felirat_t, NULL, &amp;cel);
            SDL_FreeSurface(felirat);
            SDL_DestroyTexture(felirat_t);
            w = cel.w;
        } else {
            w = 0;
        }
        /* kurzor kirajzolasa */
        if (w &lt; maxw) {
            vlineRGBA(renderer, teglalap.x + w + 2, teglalap.y + 2, teglalap.y + teglalap.h - 3, szoveg.r, szoveg.g, szoveg.b, 192);
        }
        /* megjeleniti a képernyon az eddig rajzoltakat */
        SDL_RenderPresent(renderer);

        SDL_Event event;
        SDL_WaitEvent(&amp;event);
        switch (event.type) {
            /* Kulonleges karakter */
            case SDL_KEYDOWN:
                if (event.key.keysym.sym == SDLK_BACKSPACE) {
                    int textlen = strlen(dest);
                    do {
                        if (textlen == 0) {
                            break;
                        }
                        if ((dest[textlen-1] &amp; 0x80) == 0x00)   {
                            /* Egy bajt */
                            dest[textlen-1] = 0x00;
                            break;
                        }
                        if ((dest[textlen-1] &amp; 0xC0) == 0x80) {
                            /* Bajt, egy tobb-bajtos szekvenciabol */
                            dest[textlen-1] = 0x00;
                            textlen--;
                        }
                        if ((dest[textlen-1] &amp; 0xC0) == 0xC0) {
                            /* Egy tobb-bajtos szekvencia elso bajtja */
                            dest[textlen-1] = 0x00;
                            break;
                        }
                    } while(true);
                }
                if (event.key.keysym.sym == SDLK_RETURN) {
                    enter = true;
                }
                break;

            /* A feldolgozott szoveg bemenete */
            case SDL_TEXTINPUT:
                if (strlen(dest) + strlen(event.text.text) &lt; hossz) {
                    strcat(dest, event.text.text);
                }

                /* Az eddigi szerkesztes torolheto */
                composition[0] = '\0';
                break;

            /* Szoveg szerkesztese */
            case SDL_TEXTEDITING:
                strcpy(composition, event.edit.text);
                break;

            case SDL_QUIT:
                /* visszatesszuk a sorba ezt az eventet, mert
                 * sok mindent nem tudunk vele kezdeni */
                SDL_PushEvent(&amp;event);
                kilep = true;
                break;
        }
    }

    /* igaz jelzi a helyes beolvasast; = ha enter miatt allt meg a ciklus */
    SDL_StopTextInput();
    return enter;
}

#define SZELES 480
#define MAGAS 240
#define FONT &quot;LiberationSerif-Regular.ttf&quot;
#define MAXHOSSZ 100

int main(int argc, char *argv[]) {
    SDL_Window *window;
    SDL_Renderer *renderer;
    TTF_Font *font;
    sdl_init(SZELES, MAGAS, FONT, &amp;window, &amp;renderer, &amp;font);

    SDL_Color feher = {255, 255, 255}, fekete = { 0, 0, 0 };
    SDL_Rect hely;

    char szoveg[100];

    SDL_Event event;
    SDL_Surface *screen = SDL_GetWindowSurface(window);
    SDL_Surface *background = SDL_CreateRGBSurface(0, SZELES, MAGAS, 32, 0, 0, 0, 0);

    /* hatter kirajzolasa, mentese */
    for (int i = 0; i &lt; 500; ++i)
        filledCircleRGBA(renderer, rand() % SZELES, rand() % MAGAS,
                         20 + rand() % 10, rand() % 256, rand() % 256, rand() % 256, 64);
    SDL_BlitSurface(screen, NULL, background, NULL);
    SDL_RenderPresent(renderer);

    /* szoveg bekerese */
    SDL_Rect r = { 40, 80, 400, 40 };
    input_text(szoveg, 100, r, fekete, feher, font, renderer);

    /* szoveg kirajzolasa */
    if (szoveg[0] != 0x0000) {
        SDL_BlitSurface(background, NULL, screen, NULL);

        SDL_Surface *felirat = TTF_RenderUTF8_Blended(font, szoveg, feher);
        hely.x = (screen-&gt;w - felirat-&gt;w) / 2 + 2;
        hely.y = (screen-&gt;h - felirat-&gt;h) / 2 + 2;
        SDL_BlitSurface(felirat, NULL, screen, &amp;hely);
        SDL_FreeSurface(felirat);
        SDL_RenderPresent(renderer);
        while (SDL_WaitEvent(&amp;event) &amp;&amp; event.type != SDL_QUIT);
    }

    SDL_FreeSurface(background);
    sdl_close(&amp;window, &amp;renderer, &amp;font);
    return 0;
}</code></pre>




  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Többmodulos projektek és az SDL-es programok futtatása">
<div class="slide" id="slide_8">

<a id="8" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">8</span><span class="oldalszamafter">. </span>    Többmodulos projektek és az SDL-es programok futtatása<a class="hlink" href="index.html#8"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>Van pár apróság, amit tudni kell az SDL-es projektek fordításáról és futtatásáról.</p>

<div class="sticky">Fontos!</div>

<p>Az egyik a többmodulos projektekkel kapcsolatos. A Code::Blocks beépített SDL projekt 
varázslója egy olyan projektet hoz létre, amelyben a fő forrásfájl neve <code>main.cpp</code>, 
ami a kiterjesztése miatt alapértelmezetten nem C, hanem C++ fordítóval fordul. Ha újabb modult 
adunk hozzá, annak pedig <code>.c</code> a kiterjesztése, azt a C fordító fogja kapni. Ugyan 
megoldható, hogy a kettővel együtt dolgozzunk, de ennek technikai részletei túlmutatnak a 
Prog1 tárgyon. Használjuk inkább az <a href="../sdl_telepito/index.html">SDL telepítős</a> 
írásból letölthető InfoC SDL projekt típust!</p>

<p>A másik az SDL-es programok futtatása. Az SDL könyvtár lefordított függvényei nem kerülnek be 
a mi programunk futtatható, <code>.exe</code> fájljába, hanem külön fájlokban vannak. A végleges 
linkelést nem a fordító végzi, hanem az elindított program „húzza be” az indításakor a szükséges 
programrészeket. Ezt dinamikus linkelésnek (dynamic linking) nevezzük. Ezek a függvénykönyvtárak 
a <code>*.dll</code> fájlokban (dynamic link library) vannak. Ha az SDL-es programot el 
szeretnénk indítani a Code::Blockson kívülről, akkor vele egy mappába kell tenni az SDL 
<code>*.dll</code> fájljait is. Ezek a fent letölthető ZIP fájl <code>bin</code> mappájában 
vannak. A nagyobb programok telepítőinek (installer) egyébként éppen ez a feladata, hogy a 
program futásához szükséges dinamikusan betöltött könyvtárakat is a megfelelő helyre másolják.</p>

<p>Fel szokott merülni az a kérdés is, hogyan kell olyan SDL-es programot csinálni, amelynek nem 
nyílik külön konzol ablaka az indításkor. A Code::Blocks eltérő fordítási beállítások mellett tud
<code>.exe</code> fájlt készíteni. Ha fent, a menüsor alatt a „Release” mód van kiválasztva a 
„Debug” helyett, akkor olyan <code>.exe</code> fájlt készít, amely nem nyit magának konzol 
ablakot. Az elkészült <code>.exe</code> a projekt mappájában, a <code>\bin\Release</code> 
almappa alatt található.</p>

<p>Windowson alapvetően a grafikus programoknál nem szokás az, hogy írjanak a szabványos 
kimenetükre. Ezért ott az SDL bezárja a szabványos kimenetet, és megnyit helyette egy 
<code>stdout.txt</code> nevű fájlt, amibe ezután a <code>printf()</code>-elt szövegek kerülnek. 
(Ugyanez történik a szabványos hibakimenettel is.) Ezért hiába <code>printf()</code>-elünk az 
SDL programokban, nem fog az a konzol ablakban megjelenni, még ha van is ilyen ablak. Ezt az SDL 
FAQ-ban is megemlítik, <a href="http://sdl.beuc.net/sdl.wiki/FAQ_Console">itt</a>. Ennek 
elkerülésére azt javasolják, hogy újra kell nyitni a konzol ablakot. Ezt a <code>main()</code> 
függvény elejére, de az <code>SDL_Init()</code> hívás után az alábbi módon lehet megtenni:</p>

<pre   ><code class="language-c">#ifdef __WIN32__
    freopen(&quot;CON&quot;, &quot;w&quot;, stdout);
    freopen(&quot;CON&quot;, &quot;w&quot;, stderr);
#endif</code></pre>

<p>Ezután már lehet <code>printf()</code>-elni. A <code>__WIN32__</code> makrót egyébként az SDL 
definiálja. Mivel az csak a windowsos fordításoknál létezik, a fenti négy sort nyugodtan 
betehetjük a programba (<code>#ifdef</code>-fel együtt!), platformfüggetlen marad.</p>

<p>Az SDL igényli azt is, hogy a <code>main()</code> függvénynek meglegyenek a paraméterei:
<code>int argc</code> és <code>char *argv[]</code>. Enélkül a program lefordítása nem fog mindenhol
sikerülni.</p>

<p>A parancssori argumentumokról és a többmodulos programokról egy <a href="../ea08/index.html#eaparancssori">külön előadáson</a> beszélünk majd.</p>




  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="MacOS Mojave problémák">
<div class="slide" id="slide_9">

<a id="9" class="namer"></a>
  <a id="sdlmojavebug" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">9</span><span class="oldalszamafter">. </span>    MacOS Mojave problémák<a class="hlink" href="index.html#9"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>Ha valaki a macOS Mojave legújabb verzióját használja, akkor egy SDL bug miatt nem renderelődik automatikusan a képernyőre, 
amit rajzolni szeretnénk. A probléma megoldódik, ha megmozdítjuk az SDL által készített ablakot ÉS az események kezelésébe 
beleteszünk egy <code>SDL_RenderPresent(renderer)</code> sort.</p>

<p>Az első SDL példaprogram esetében ez így nézne ki:</p>

<pre   ><code class="language-c">/* varunk a kilepesre */
SDL_Event ev;
while (SDL_WaitEvent(&amp;ev) &amp;&amp; ev.type != SDL_QUIT) {
    SDL_RenderPresent(renderer);
}</code></pre>
  
    </div>

<div class="clear"></div>

</div>
</section>

</div>
</main>

<footer role="contentinfo">
<div class="shaper">
<div class="footer ">
  <a href="../index/index.html"><img src="../modulz/logo.png" class="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon">
            <a href="../index/index.html">főoldal</a>
         ·     <a href="../elerhetoseg/index.html">elérhetőség</a>
         ·     <a href="../elerhetoseg/index.html#licenc">licenc</a>
         ·     <a href="https://www.facebook.com/infoceetbmehu">facebook</a>
    </div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2021.</div>
</div>
</footer>

</div>

<nav>
<a id="scrolltotop"></a>
</nav>

</body>

</html>
