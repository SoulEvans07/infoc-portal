<!DOCTYPE html>
<html lang="hu">

<head>
<meta charset="utf-8">
<title>TEST InfoC :: Gyorsrendezés – még egy rekurzív rendezés</title>
<meta property="og:title" content="TEST InfoC :: Gyorsrendezés – még egy rekurzív rendezés">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="TEST InfoC :: Gyorsrendezés – még egy rekurzív rendezés">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="TEST InfoC :: Gyorsrendezés – még egy rekurzív rendezés">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<link rel="stylesheet" href="../modulz/alap-infoc.css@v101.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v101.css">
<script>var infoc = { onloads: [] };</script>
<script src="../modulz/site.js@v101"></script>
<script src="osszesscript.js@v101"></script>
</head>

<body class=" doksi-formatum" data-version="101"
    data-halozati-hiba="Hálózati hiba a kérés teljesítése közben."
    data-tul-nagy-keres="A fájl túl nagy!"
    data-biztos-navigal="Biztos el szeretnél navigálni? A nem mentett változások elvesznek."
    data-ird-be-a-keresoszot="Írd be a keresőszót!"
    data-vissza="Vissza">

<div class="bodycontent">

<nav class="menubg clearfix">
<div class="shaper">
<div id="menu" class="menu menu-font-size">
<a id="menu-nyito" class="menu-nyito"  role="button"><i class="hamburger"></i></a>
<div class="menu-brand"><a href="../index/index.html">InfoC</a></div>
<div id="menu-elemek" class="menu-elemek">
<ul>
<li class="almenu "><a>Infó</a>
<ul>
<li><a  href="../index/index.html">Kezdőlap</a>
<li><a  href="../elerhetoseg/index.html">Elérhetőség</a>
</ul>

<li class="almenu "><a>Tananyag</a>
<ul>
<li class="almenu "><a>Előadás</a>
<ul>
<li><a  href="../ea01/index.html">1. hét: típusok, változók, vezérlés</a>
<li><a  href="../ea02/index.html">2. hét: nevezetes algoritmusok, tömbök</a>
<li><a  href="../ea03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../ea04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../ea05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../ea06/index.html">6. hét: operátorok, számábrázolás</a>
<li><a  href="../ea07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../ea08/index.html">8. hét: fájlkezelés, modulok</a>
<li><a  href="../ea10/index.html">10. hét: láncolt listák</a>
<li><a  href="../ea11/index.html">11. hét: bináris fák</a>
<li><a  href="../ea12/index.html">12. hét: állapotgépek, reguláris kifejezések</a>
<li><a  href="../ea13/index.html">13. hét: generikus algoritmusok, visszalépő keresés</a>
<li><a  href="../ea14/index.html">14. hét: összefoglalás</a>
</ul>

<li class="almenu "><a>Labor</a>
<ul>
<li><a  href="../lab01/index.html">1. hét: parancssor, ZIP</a>
<li><a  href="../lab02/index.html">2. hét: egyszerű programok</a>
<li><a  href="../lab03/index.html">3. hét: tömbök, nevezetes algoritmusok</a>
<li><a  href="../lab04/index.html">4. hét: struktúrák és függvények</a>
<li><a  href="../lab06/index.html">6. hét: pointerek, sztringek</a>
<li><a  href="../lab07/index.html">7. hét: rekurzió</a>
<li><a  href="../lab08/index.html">8. hét: dinamikus tömbök I.</a>
<li><a  href="../lab09/index.html">9. hét: dinamikus tömbök II.</a>
<li><a  href="../lab10/index.html">10. hét: láncolt listák</a>
<li><a  href="../lab11/index.html">11. hét: bináris fák</a>
<li><a  href="../lab12/index.html">12. hét: gyakorlás NZH-ra</a>
<li><a  href="../lab13/index.html">13. hét: állapotgépek</a>
<li><a  href="../lab14/index.html">14. hét: labirintus játék</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../gy01/index.html">1. hét: adatmodellezés, algoritmusok</a>
<li><a  href="../gy02/index.html">2. hét: tanult algoritmusok</a>
<li><a  href="../gy03/index.html">3. hét: egyszerű programok</a>
<li><a  href="../gy04/index.html">4. hét: tételek és tömbök</a>
<li><a  href="../gy05/index.html">5. hét: származtatott típusok</a>
<li><a  href="../gy06/index.html">6. hét: karakterek, számrendszerek</a>
<li><a  href="../gy07/index.html">7. hét: pointerek használata</a>
<li><a  href="../gy08/index.html">8. hét: rekurzió</a>
<li><a  href="../gy09/index.html">9. hét: dinamikus tömbök</a>
<li><a  href="../gy10/index.html">10. hét: láncolt listák</a>
<li><a  href="../gy12/index.html">12. hét: bináris fák</a>
<li><a  href="../gy13/index.html">13. hét: állapotgépek</a>
<li><a  href="../gy14/index.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="almenu "><a>Példatár</a>
<ul>
<li><a  href="../f01/index.html">1. hét: egyszerű programok</a>
<li><a  href="../f02/index.html">2. hét: logika, sorozatok, tömbök</a>
<li><a  href="../f03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../f04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../f05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../f06/index.html">6. hét: számábrázolás, bitek</a>
<li><a  href="../f07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../f08/index.html">8. hét: parancssor, fájlkezelés, modulok</a>
<li><a  href="../f10/index.html">10. hét: láncolt listák</a>
<li><a  href="../f11/index.html">11. hét: bináris fák, többszörös indirekció</a>
<li><a  href="../f12/index.html">12. hét: állapotgépek</a>
<li><a  href="../f13/index.html">13. hét: generikus algoritmusok</a>
</ul>

<li><a  href="../nhflista/index.html">Nagy házi lista</a>
</ul>

<li class="almenu "><a>Segédlet</a>
<ul>
<li><a  href="../jegyzet/index.html">Jegyzet és puska</a>
<li><a  href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a  href="../stilus/index.html">Kódolási stílus</a>
<li><a  href="../for_vs_while/index.html">For vagy while?</a>
<li class="almenu "><a>Nagy házi</a>
<ul>
<li><a  href="../mintanhf/index.html">Minta nagy házi</a>
<li><a  href="../nhfspecifikacio/index.html">Specifikáció: hogyan?</a>
<li><a  href="../debugmalloc/index.html">Debugmalloc, memóriakezelés</a>
<li><a  href="../fajlkezeles/index.html">Fájlkezelés, mappák</a>
<li><a  href="../megjelenites/index.html">Szöveges és grafikus megjelenítés</a>
<li><a  href="../scanf/index.html">Scanf problémák</a>
<li><a  href="../scanf_hibakezeles/index.html">Scanf és hibakezelés</a>
<li><a  href="../karakterkodolas/index.html">Karakterkódolások</a>
<li><a  href="../cbtobbmodul/index.html">Több modulos programok</a>
</ul>

<li class="almenu "><a>ZH</a>
<ul>
<li><a  href="../tldr1/index.html">TL;DR I.</a>
<li><a  href="../tldr2/index.html">TL;DR II.</a>
</ul>

</ul>

<li class="almenu "><a>Extrák</a>
<ul>
<li class="almenu "><a>SVG óra galéria</a>
<ul>
<li><a  href="../orak2021/index.html">SVG óra galéria 2021</a>
<li><a  href="../orak2020/index.html">SVG óra galéria 2020</a>
<li><a  href="../orak2019/index.html">SVG óra galéria 2019</a>
<li><a  href="../orak2018/index.html">SVG óra galéria 2018</a>
<li><a  href="../orak2017/index.html">SVG óra galéria 2017</a>
<li><a  href="../orak2016/index.html">SVG óra galéria 2016</a>
<li><a  href="../orak2015/index.html">SVG óra galéria 2015</a>
</ul>

<li class="almenu "><a>NHF galéria</a>
<ul>
<li><a  href="../nhfgaleria2021/index.html">NHF galéria 2021</a>
<li><a  href="../nhfgaleria2020/index.html">NHF galéria 2020</a>
<li><a  href="../nhfgaleria2019/index.html">NHF galéria 2019</a>
<li><a  href="../nhfgaleria2018/index.html">NHF galéria 2018</a>
<li><a  href="../nhfgaleria2017/index.html">NHF galéria 2017</a>
<li><a  href="../nhfgaleria2016/index.html">NHF galéria 2016</a>
<li><a  href="../nhfgaleria2015/index.html">NHF galéria 2015</a>
<li><a  href="../nhfgaleria2014/index.html">NHF galéria 2014</a>
<li><a  href="../nhfgaleria2013/index.html">NHF galéria 2013</a>
<li><a  href="../nhfgaleria2012/index.html">NHF galéria 2012</a>
</ul>

<li class="almenu "><a>Elmélet</a>
<ul>
<li><a  href="../turing/index.html">Mit tud a számítógép?</a>
<li><a  href="../bf/index.html">BF</a>
<li><a  href="../bitturmix/index.html">Bitturmix</a>
<li><a  href="../kifesto/index.html">Zárt terület kifestése</a>
<li><a  href="../labirintus/index.html">Labirintusok</a>
<li><a  href="index.html">Gyorsrendezés</a>
<li><a  href="../tripla/index.html">Tripla indirekció</a>
<li><a  href="../generikus/index.html">Generikus lista</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../strlcpy/index.html">Kulturált sztringmásoló</a>
<li><a  href="../xor_csere/index.html">XOR csere</a>
<li><a  href="../include/index.html">include</a>
<li><a  href="../inline/index.html">inline</a>
<li><a  href="../internet/index.html">Internet</a>
</ul>

<li class="almenu "><a>Grafika</a>
<ul>
<li><a  href="../sdl/index.html">SDL grafika</a>
<li><a  href="../sdl_telepito/index.html">SDL telepítés</a>
<li><a  href="../fa/index.html">Fák rajzolása</a>
</ul>

<li class="almenu "><a>Nyelvészet</a>
<ul>
<li><a  href="../mondatelemzo/index.html">Mondatelemző</a>
<li><a  href="../kifejezesek/index.html">Kifejezések</a>
<li><a  href="../derivalas/index.html">Deriválás</a>
</ul>

<li><a  href="../advent/index.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</div>
</nav>

<div class="menu-font-size"><div class="menuplaceholder"></div></div>

<main class="doksi">
<div class="shaper">


<section class="slidescreen" data-title="Gyorsrendezés – még egy rekurzív rendezés">
<div class="slide" id="slide_0">

<a id="0" class="namer"></a>


<div class="slidecontent">
  <h1 class="eloadascim">Gyorsrendezés – még egy rekurzív rendezés</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán · <i class="ido"></i> 2019.02.27.</p>
<p class="kivonat"></p>
</div>


<div class="sticky">Feltalálója:<br>Tony Hoare</div>

<p>A gyorsrendezés (quick sort) egy rekurzív rendezőalgoritmus. Lényege: egy elemet vezérelemnek választva két részre osztjuk a 
tömböt: a vezérelemnél kisebbekre és nagyobbakra. Ha a kicsiket a tömb elejére, a nagyokat a tömb végére tesszük, azzal közelebb 
kerülünk a rendezett állapothoz.</p>

<p>A gyorsrendezés jól optimalizálható, ha számokat kell rendezni. Mivel minden összehasonlítás a vezérelemet vizsgálja, azt 
körönként csak egyszer kell kiolvasni a memóriából. (Ez persze a C kódban nem látszik, csak a fordító által optimalizáltban.) <a 
href="http://en.wikipedia.org/wiki/C._A._R._Hoare#Further_reading">C. A. R. Hoare</a> angol programozó, matematikus. Legismertebb 
eredménye ez az algoritmus, amelyet 26 évesen dolgozott ki.</p>


  
        <nav id="tartalom">
      <h3>Tartalom</h3>
      <ol>              <li><a href="index.html#1" class="">Az algoritmus működése</a>
              <li><a href="index.html#2" class="">Szétválogatás – kékek előre, pirosak hátra</a>
              <li><a href="index.html#3" class="">gyorsrendez.c</a>
              <li><a href="index.html#4" class="">Az apróbetűs rész</a>
            </ol>    </nav>
  </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Az algoritmus működése">
<div class="slide" id="slide_1">

<a id="1" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">1</span><span class="oldalszamafter">. </span>    Az algoritmus működése<a class="hlink" href="index.html#1"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>A gyorsrendezés az „oszd meg és uralkodj” elven működik. Lépései a következők:</p>

<ul>
   <li>Kiválasztunk a tömbből egy tetszőleges elemet. Ez lesz az ún. vezérelem (pivot).
   <li>Az ennél kisebbeket a tömb elejére, az ennél nagyobbakat a tömb végére rendezzük.
      A vezérelemmel megegyező elemek mehetnek bármelyik oldalra.
   <li>Ezután az így keletkező két tömbrészletet külön rendezzük, az algoritmus rekurzív hívásával.
</ul>

<br>

<div>
<div id="qsorttomb" class="tomb"></div>
<div id="qsorttombcapt" class="tombcaption"></div>
</div>

<p class="kozep">
   <button id="qsorttombstart">start</button>
   <button id="qsorttombkovetkezo">következő</button>
   <button id="qsorttombfolyamatos">folyamatos</button>
</p>

<br>

<p>Érdemes megfigyelni a következőt: ha a vezérelem elé rendeztük a kisebbeket, mögé a nagyobbakat, az azt jelenti, hogy a 
vezérelem már a végleges helyére kerül. Ugyanis ha nála kisebből van emennyi (előtte), nála nagyobból meg amannyi (utána), akkor 
ezek a számok egyben a vezérelem helyét is meghatározzák. Hiszen ezek (emennyi és amannyi) nem fognak már változni.</p>
   
<p>Az algoritmus hatékonysága azon múlik, hogy sikerül-e jó vezérelemet választani. Akkor lehet minden lépésben a kisebbekre és 
nagyobbakra szedett tömbrészeket egyenlő nagyságúvá tenni (vagyis felezni a tömböt), ha a vezérelem éppen a tömb mediánja, azaz a 
rendezett tömb középső eleme. Sajnos a mediánt nem tudjuk megmondani, hiszen ahhoz rendezve kellene legyen a tömb… Ezért leginkább 
azt szokták csinálni, hogy találomra választanak egyet, akár éppen az elsőt vezérelemnek, és kész. Ez persze nem optimális minden 
esetben. Pár „start” gomb klikkelés után ez látszik is, ha kijön egy olyan tömb, ahol 1 vagy 9 az első elem. Ilyenkor az első 
körben szinte semmi nem történik. Emiatt van az, hogy bár átlagos esetben ez az algoritmus Θ(n log n) időben tud teljesíteni, de 
legrosszabb esetben ugyanúgy O(n<sup>2</sup>) időben fut le, mint egy buborékrendezés.</p>






  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Szétválogatás – kékek előre, pirosak hátra">
<div class="slide" id="slide_2">

<a id="2" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">2</span><span class="oldalszamafter">. </span>    Szétválogatás – kékek előre, pirosak hátra<a class="hlink" href="index.html#2"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>A szétválogatás működésének lényege: a tömb két végéről indulnak indexek. Megkeressük balról az első pirosat, jobbról kéket, és 
megcseréljük őket. Ezt folytatjuk, amíg a két index nem találkozik.</p>

<br>

<div>
    <div id="szetvalogat" class="tomb"></div>
    <div id="szetvalogatcapt" class="tombcaption"></div>
</div>

<p class="kozep">
   <button id="szetvalogatstart">start</button>
   <button id="szetvalogatkovetkezo">következő</button>
</p>

<br>

<p>Kicsit részletesebben:</p>

<ol>
   <li>Indítunk két indexet, egyiket a tömb elejéről (bal), másikat a végéről (jobb).
   <li>Balt addig növeljük, amíg kék golyóra mutat. Így találunk egy piros golyót.
   <li>Jobbat addig csökkentjük, amíg piros golyóra mutat. Így
   <li>Megcseréljük a talált pirosat a kékkel, és így folytatjuk, amíg
      a két index „össze nem ér”.
</ol>

<p>Minden csere után természetesen növelhetjük a balt és csökkenthetjük a jobbat eggyel, hiszen a csere hatására a bal index alá 
kék, a jobb index alá pedig piros golyó kerül. Fontos, hogy a keresések során is figyeljük, hogy nem értek-e össze az indexek; ez 
előfordulhat ugyanis bármelyik pillanatban. (Ezzel azt is ellenőrizzük, hogy nem érünk-e a tömb végére valamelyik indexszel. Az is 
lehetséges, ha a tömb csak kék vagy csak piros golyót tartalmaz.)</p>

<pre   ><code class="language-cbub">enum golyo { kek, piros };

void szetvalogat(enum golyo *tomb, int meret) {
   int bal = 0, jobb = meret-1;

   while (bal &lt; jobb) {
      while (bal &lt; jobb &amp;&amp; tomb[bal] != piros)  // pirosat keres
         ++bal;
      while (bal &lt; jobb &amp;&amp; tomb[jobb] != kek)   // kéket keres
         --jobb;

      if (bal &lt; jobb) {
         enum golyo temp = tomb[bal];   // csere
         tomb[bal] = tomb[jobb];
         tomb[jobb] = temp;
         ++bal;
         --jobb;        // egyből a következőkre
      }
   }
}</code></pre>

<p>Vagyis pl. a kereső ciklusok megállhatnak így:</p>

<div class="tomb" style="width: 20.5em;">
<span class="kek">0</span>
<span class="kek">0</span>
<span class="piros jelolt">1</span>
<span class="piros">1</span>
<span class="kek">0</span>
<span class="piros">1</span>
<span class="kek jelolt">0</span>
<span class="piros">1</span>
</div>

<p>Ha megcseréljük a <code>tomb[bal]</code> és a <code>tomb[jobb]</code> elemet:</p>

<div class="tomb" style="width: 20.5em;">
<span class="kek">0</span>
<span class="kek">0</span>
<span class="kek jelolt">0</span>
<span class="piros">1</span>
<span class="kek">0</span>
<span class="piros">1</span>
<span class="piros jelolt">1</span>
<span class="piros">1</span>
</div>

<p>Akkor a csere után a két indexet gondolkodás nélkül növelhetjük és csökkenthetjük:</p>

<div class="tomb" style="width: 20.5em;">
<span class="kek">0</span>
<span class="kek">0</span>
<span class="kek">0</span>
<span class="piros jelolt">1</span>
<span class="kek">0</span>
<span class="piros jelolt">1</span>
<span class="piros">1</span>
<span class="piros">1</span>
</div>

<p>És innen folytatjuk megint piros-kék kereséssel.</p>










  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="gyorsrendez.c">
<div class="slide" id="slide_3">

<a id="3" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">3</span><span class="oldalszamafter">. </span>    gyorsrendez.c<a class="hlink" href="index.html#3"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<pre   ><code class="language-cbub">void gyorsrendez(double *tomb, int min, int max) {
   double vezer = tomb[(min+max)/2]; // vezérelem: középső
   int i = min, j = max;
   while (i &lt;= j) {                  // piros/kék válogatás
      while (tomb[i] &lt; vezer) ++i;
      while (tomb[j] &gt; vezer) --j;
      if (i &lt;= j) {
         double tmp = tomb[i];
         tomb[i] = tomb[j];
         tomb[j] = tmp;
         ++i;
         --j;
      }
   }

   if (min &lt; j) gyorsrendez(tomb, min, j); // rekurzió
   if (i &lt; max) gyorsrendez(tomb, i, max);
}</code></pre>

<p>Az algoritmus részei: a <code>while (i &lt;= j)</code> ciklus végzi a szétválogatást; utána pedig az utolsó két sorban láthatók 
a rekurzív hívások, amelyek rendezik a tömb így keletkezett két részét.</p>

<p>Az <code>i&lt;=j</code> ciklus végefelé az <code>i</code> és a <code>j</code> index is a már helyre került vezérelemnél áll. A 
belső, piros-kék keresős ciklusok megállnak a megtalált vezérelemnél is, hiszen elem&lt;vezér és elem&gt;vezér kifejezések a 
feltételeik. (Tehát a pirosat kereső ciklusnak a vezérelem pirosnak számít, a kéket kereső ciklusnak a vezérelem kéknek számít. Ha 
a vezérelem elöl van, akkor egy cserében hátrébb kerül, ha hátul van, akkor egy cserében előrébb kerül. Előfordulhat, hogy ide-oda 
pattog, de végül középre fog kerülni.) A ciklus futása után egy ilyen állapot lesz a tömbben:</p>

<div class="tomb" style="width: 23em;">
<span class="kek">min</span>
<span class="kek">&nbsp;</span>
<span class="kek">&nbsp;</span>
<span class="kek">&nbsp;</span>
<span class="pivot jelolt">i,j</span>
<span class="piros">&nbsp;</span>
<span class="piros">&nbsp;</span>
<span class="piros">&nbsp;</span>
<span class="piros">max</span>
</div>

<p>Ezután az <code>i++</code> és <code>j--</code> utasítással még módosítjuk az indexeket (lásd a szétválogatási feladatot). Így 
<code>i</code> és <code>j</code> a rendezendő két részintervallum széleit is jelzik, és az eddigiektől eltérően <code>j&lt;i</code> 
igaz:</p>

<div class="tomb" style="width: 23em;">
<span class="kek">min</span>
<span class="kek">&nbsp;</span>
<span class="kek">&nbsp;</span>
<span class="kek jelolt">j</span>
<span class="pivot">&nbsp;</span>
<span class="piros jelolt">i</span>
<span class="piros">&nbsp;</span>
<span class="piros">&nbsp;</span>
<span class="piros">max</span>
</div>

<p>Ezért van az, hogy a két rendezendő tömbrészlet a <code>[min,j]</code> és az <code>[i,max]</code> indexű részek.</p>

<p>Az előzőektől eltérően ennek a függvénynek nem a tömb méretét kell megadni, hanem a rendezendő intervallum alsó és felső 
határát. De ez nem gond, hiszen egy egysoros függvénnyel ugyanolyan formában használhatjuk ezt is:</p>

<pre   ><code class="language-c">void gyorsrendez_indit(double *tomb, int meret) {
   gyorsrendez(tomb, 0, meret-1);
}</code></pre>





  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Az apróbetűs rész">
<div class="slide" id="slide_4">

<a id="4" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">4</span><span class="oldalszamafter">. </span>    Az apróbetűs rész<a class="hlink" href="index.html#4"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>A fenti kód a gyorsrendezésnek csak egy variációja. Nem az igazi algoritmus, hanem egy olyan változat, amelyen keresztül könnyű 
megérteni a működést. Ugyanis nem igaz rá, hogy egy körben az aktuális vezérelem a helyére kerül. Arról van szó, hogy ha a 
vezérelem két oldalán keresett nála nagyobb, illetve kisebb elemek nem egyszerre fogynak el, akkor a vezérelem vándorolni kezd és 
az <code>i</code>, <code>j</code> mutatók csak az egyik oldalára kerülnek. Ezért pedig az aktuális vezérelem csak egy későbbi 
függvényhívásnál kerül helyre.</p>

<p>Ezt az okozza, hogy a szétválogatásban nem csak kékek és pirosak vannak, hanem van a vezérelem, a sárga is. Azt a sima kék-piros
szétválogatásnál elvileg kéknek is és pirosnak is (vagy: kéknek sem és pirosnak sem) <a
href="https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme">kellene tekinteni</a>. Ideális esetben ide-oda pingpongozna a
két ciklus a vezérelemmel, úgy tudna az középen megérkezni.</p>

<p>Viszont ennek a megvalósítása nem triviális. Ehhez az kellene, hogy a csere után ne azt mondjuk, hogy <code>++i</code> és 
<code>--j</code>, hanem hogy <code>if (tomb[i]!=vezer) ++i;</code>, és <code>if (tomb[j]!=vezer) --j;</code>, hogy a pingpongozás 
megvalósulhasson (egymás után kétszer is elmozdíthassuk ugyanazt az elemet). Ez viszont <a 
href="https://en.wikipedia.org/wiki/Quicksort#Repeated_elements">végtelen ciklust eredményezhetne</a> akkor, ha a vezérelem olyan 
értékű, amiből kettő van.</p>

<p>Tehát a szétválogatás (particionálás) a fenti kódban nem tökéletes. De a gyorsrendezéshez elegendő, mert a szétválogatás
által hagyott hibát a későbbi rendezési lépések kijavítják.</p>
  
    </div>

<div class="clear"></div>

</div>
</section>

</div>
</main>

<footer role="contentinfo">
<div class="shaper">
<div class="footer ">
  <a href="../index/index.html"><img src="../modulz/logo.png" class="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon">
            <a href="../index/index.html">főoldal</a>
         ·     <a href="../elerhetoseg/index.html">elérhetőség</a>
         ·     <a href="../elerhetoseg/index.html#licenc">licenc</a>
         ·     <a href="https://www.facebook.com/infoceetbmehu">facebook</a>
    </div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2021.</div>
</div>
</footer>

</div>

<nav>
<a id="scrolltotop"></a>
</nav>

</body>

</html>
