<!DOCTYPE html>
<html lang="hu">

<head>
<meta charset="utf-8">
<title>TEST InfoC :: Gyakorlat, 10. hét: láncolt listák</title>
<meta property="og:title" content="TEST InfoC :: Gyakorlat, 10. hét: láncolt listák">
<meta property="og:image" content="/modulz/logo.png">
<meta property="og:description" content="Láncolt listák építése és kezelése.">
<meta property="og:site_name" content="InfoC – Programozás alapjai I.">
<meta name="description" content="Láncolt listák építése és kezelése.">
<meta name="robots" content="noarchive">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" href="../modulz/favicon.ico" id="faviconhref">
<link rel="apple-touch-icon" href="../modulz/logo_touch.png">
<link rel="image_src" href="../modulz/logo.png"> 
<link rel="stylesheet" href="../modulz/alap-infoc.css@v101.css">
<link rel="stylesheet" href="../modulz/style/localfonts.css@v101.css">
<script>var infoc = { onloads: [] };</script>
<script src="../modulz/site.js@v101"></script>
</head>

<body class=" doksi-formatum" data-version="101"
    data-halozati-hiba="Hálózati hiba a kérés teljesítése közben."
    data-tul-nagy-keres="A fájl túl nagy!"
    data-biztos-navigal="Biztos el szeretnél navigálni? A nem mentett változások elvesznek."
    data-ird-be-a-keresoszot="Írd be a keresőszót!"
    data-vissza="Vissza">

<div class="bodycontent">

<nav class="menubg clearfix">
<div class="shaper">
<div id="menu" class="menu menu-font-size">
<a id="menu-nyito" class="menu-nyito"  role="button"><i class="hamburger"></i></a>
<div class="menu-brand"><a href="../index/index.html">InfoC</a></div>
<div id="menu-elemek" class="menu-elemek">
<ul>
<li class="almenu "><a>Infó</a>
<ul>
<li><a  href="../index/index.html">Kezdőlap</a>
<li><a  href="../elerhetoseg/index.html">Elérhetőség</a>
</ul>

<li class="almenu "><a>Tananyag</a>
<ul>
<li class="almenu "><a>Előadás</a>
<ul>
<li><a  href="../ea01/index.html">1. hét: típusok, változók, vezérlés</a>
<li><a  href="../ea02/index.html">2. hét: nevezetes algoritmusok, tömbök</a>
<li><a  href="../ea03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../ea04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../ea05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../ea06/index.html">6. hét: operátorok, számábrázolás</a>
<li><a  href="../ea07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../ea08/index.html">8. hét: fájlkezelés, modulok</a>
<li><a  href="../ea10/index.html">10. hét: láncolt listák</a>
<li><a  href="../ea11/index.html">11. hét: bináris fák</a>
<li><a  href="../ea12/index.html">12. hét: állapotgépek, reguláris kifejezések</a>
<li><a  href="../ea13/index.html">13. hét: generikus algoritmusok, visszalépő keresés</a>
<li><a  href="../ea14/index.html">14. hét: összefoglalás</a>
</ul>

<li class="almenu "><a>Labor</a>
<ul>
<li><a  href="../lab01/index.html">1. hét: parancssor, ZIP</a>
<li><a  href="../lab02/index.html">2. hét: egyszerű programok</a>
<li><a  href="../lab03/index.html">3. hét: tömbök, nevezetes algoritmusok</a>
<li><a  href="../lab04/index.html">4. hét: struktúrák és függvények</a>
<li><a  href="../lab06/index.html">6. hét: pointerek, sztringek</a>
<li><a  href="../lab07/index.html">7. hét: rekurzió</a>
<li><a  href="../lab08/index.html">8. hét: dinamikus tömbök I.</a>
<li><a  href="../lab09/index.html">9. hét: dinamikus tömbök II.</a>
<li><a  href="../lab10/index.html">10. hét: láncolt listák</a>
<li><a  href="../lab11/index.html">11. hét: bináris fák</a>
<li><a  href="../lab12/index.html">12. hét: gyakorlás NZH-ra</a>
<li><a  href="../lab13/index.html">13. hét: állapotgépek</a>
<li><a  href="../lab14/index.html">14. hét: labirintus játék</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../gy01/index.html">1. hét: adatmodellezés, algoritmusok</a>
<li><a  href="../gy02/index.html">2. hét: tanult algoritmusok</a>
<li><a  href="../gy03/index.html">3. hét: egyszerű programok</a>
<li><a  href="../gy04/index.html">4. hét: tételek és tömbök</a>
<li><a  href="../gy05/index.html">5. hét: származtatott típusok</a>
<li><a  href="../gy06/index.html">6. hét: karakterek, számrendszerek</a>
<li><a  href="../gy07/index.html">7. hét: pointerek használata</a>
<li><a  href="../gy08/index.html">8. hét: rekurzió</a>
<li><a  href="../gy09/index.html">9. hét: dinamikus tömbök</a>
<li><a  href="index.html">10. hét: láncolt listák</a>
<li><a  href="../gy12/index.html">12. hét: bináris fák</a>
<li><a  href="../gy13/index.html">13. hét: állapotgépek</a>
<li><a  href="../gy14/index.html">14. hét: generikus algoritmusok</a>
</ul>

<li class="almenu "><a>Példatár</a>
<ul>
<li><a  href="../f01/index.html">1. hét: egyszerű programok</a>
<li><a  href="../f02/index.html">2. hét: logika, sorozatok, tömbök</a>
<li><a  href="../f03/index.html">3. hét: függvények, struktúrák</a>
<li><a  href="../f04/index.html">4. hét: pointerek, sztringek</a>
<li><a  href="../f05/index.html">5. hét: rendezések, rekurzió</a>
<li><a  href="../f06/index.html">6. hét: számábrázolás, bitek</a>
<li><a  href="../f07/index.html">7. hét: dinamikus memóriakezelés</a>
<li><a  href="../f08/index.html">8. hét: parancssor, fájlkezelés, modulok</a>
<li><a  href="../f10/index.html">10. hét: láncolt listák</a>
<li><a  href="../f11/index.html">11. hét: bináris fák, többszörös indirekció</a>
<li><a  href="../f12/index.html">12. hét: állapotgépek</a>
<li><a  href="../f13/index.html">13. hét: generikus algoritmusok</a>
</ul>

<li><a  href="../nhflista/index.html">Nagy házi lista</a>
</ul>

<li class="almenu "><a>Segédlet</a>
<ul>
<li><a  href="../jegyzet/index.html">Jegyzet és puska</a>
<li><a  href="../fejlesztokornyezet.html">Fejlesztőkörnyezetek</a>
<li><a  href="../stilus/index.html">Kódolási stílus</a>
<li><a  href="../for_vs_while/index.html">For vagy while?</a>
<li class="almenu "><a>Nagy házi</a>
<ul>
<li><a  href="../mintanhf/index.html">Minta nagy házi</a>
<li><a  href="../nhfspecifikacio/index.html">Specifikáció: hogyan?</a>
<li><a  href="../debugmalloc/index.html">Debugmalloc, memóriakezelés</a>
<li><a  href="../fajlkezeles/index.html">Fájlkezelés, mappák</a>
<li><a  href="../megjelenites/index.html">Szöveges és grafikus megjelenítés</a>
<li><a  href="../scanf/index.html">Scanf problémák</a>
<li><a  href="../scanf_hibakezeles/index.html">Scanf és hibakezelés</a>
<li><a  href="../karakterkodolas/index.html">Karakterkódolások</a>
<li><a  href="../cbtobbmodul/index.html">Több modulos programok</a>
</ul>

<li class="almenu "><a>ZH</a>
<ul>
<li><a  href="../tldr1/index.html">TL;DR I.</a>
<li><a  href="../tldr2/index.html">TL;DR II.</a>
</ul>

</ul>

<li class="almenu "><a>Extrák</a>
<ul>
<li class="almenu "><a>SVG óra galéria</a>
<ul>
<li><a  href="../orak2021/index.html">SVG óra galéria 2021</a>
<li><a  href="../orak2020/index.html">SVG óra galéria 2020</a>
<li><a  href="../orak2019/index.html">SVG óra galéria 2019</a>
<li><a  href="../orak2018/index.html">SVG óra galéria 2018</a>
<li><a  href="../orak2017/index.html">SVG óra galéria 2017</a>
<li><a  href="../orak2016/index.html">SVG óra galéria 2016</a>
<li><a  href="../orak2015/index.html">SVG óra galéria 2015</a>
</ul>

<li class="almenu "><a>NHF galéria</a>
<ul>
<li><a  href="../nhfgaleria2021/index.html">NHF galéria 2021</a>
<li><a  href="../nhfgaleria2020/index.html">NHF galéria 2020</a>
<li><a  href="../nhfgaleria2019/index.html">NHF galéria 2019</a>
<li><a  href="../nhfgaleria2018/index.html">NHF galéria 2018</a>
<li><a  href="../nhfgaleria2017/index.html">NHF galéria 2017</a>
<li><a  href="../nhfgaleria2016/index.html">NHF galéria 2016</a>
<li><a  href="../nhfgaleria2015/index.html">NHF galéria 2015</a>
<li><a  href="../nhfgaleria2014/index.html">NHF galéria 2014</a>
<li><a  href="../nhfgaleria2013/index.html">NHF galéria 2013</a>
<li><a  href="../nhfgaleria2012/index.html">NHF galéria 2012</a>
</ul>

<li class="almenu "><a>Elmélet</a>
<ul>
<li><a  href="../turing/index.html">Mit tud a számítógép?</a>
<li><a  href="../bf/index.html">BF</a>
<li><a  href="../bitturmix/index.html">Bitturmix</a>
<li><a  href="../kifesto/index.html">Zárt terület kifestése</a>
<li><a  href="../labirintus/index.html">Labirintusok</a>
<li><a  href="../qsort/index.html">Gyorsrendezés</a>
<li><a  href="../tripla/index.html">Tripla indirekció</a>
<li><a  href="../generikus/index.html">Generikus lista</a>
</ul>

<li class="almenu "><a>Gyakorlat</a>
<ul>
<li><a  href="../strlcpy/index.html">Kulturált sztringmásoló</a>
<li><a  href="../xor_csere/index.html">XOR csere</a>
<li><a  href="../include/index.html">include</a>
<li><a  href="../inline/index.html">inline</a>
<li><a  href="../internet/index.html">Internet</a>
</ul>

<li class="almenu "><a>Grafika</a>
<ul>
<li><a  href="../sdl/index.html">SDL grafika</a>
<li><a  href="../sdl_telepito/index.html">SDL telepítés</a>
<li><a  href="../fa/index.html">Fák rajzolása</a>
</ul>

<li class="almenu "><a>Nyelvészet</a>
<ul>
<li><a  href="../mondatelemzo/index.html">Mondatelemző</a>
<li><a  href="../kifejezesek/index.html">Kifejezések</a>
<li><a  href="../derivalas/index.html">Deriválás</a>
</ul>

<li><a  href="../advent/index.html">Adventi naptár</a>
</ul>

</ul>
</div>
</div>
</div>
</nav>

<div class="menu-font-size"><div class="menuplaceholder"></div></div>

<main class="doksi">
<div class="shaper">


<section class="slidescreen" data-title="Gyakorlat, 10. hét: láncolt listák">
<div class="slide" id="slide_0">

<a id="0" class="namer"></a>
  <a id="gyaklista" class="namer"></a>


<div class="slidecontent">
  <h1 class="eloadascim">Gyakorlat, 10. hét: láncolt listák</h1>
<div class="focim">
<p class="szerzocim"><i class="szerzo"></i> Czirkos Zoltán · <i class="ido"></i> 2021.08.24.</p>
<p class="kivonat">Láncolt listák építése és kezelése.</p>
</div>






<p>Láncolt listák használata. Az óra célja az, hogy mindenki gyakorlatot szerezzen a listák használatában – különösen abban, hogyan 
kell a pointereket az egyes beszúrás, törlés stb. műveleteknél állítani. Ehhez minden esetben javasolt rajz készítése!</p>

<p>Felkészülés a gyakorlatra:</p>
<ul>
    <li>A <a href="../ea10/index.html#ealista">listákról szóló előadás</a> anyagának megértése.
    <li>A <a href="../ea07/index.html#eadinamikusmemoria">dinamikus memóriakezelésről szóló előadás</a> átismétlése.
</ul>









  
        <nav id="tartalom">
      <h3>Tartalom</h3>
      <ol>              <li><a href="index.html#1" class="">Megfordít</a>
              <li><a href="index.html#2" class="">Adott tulajdonságú elemek törlése</a>
              <li><a href="index.html#3" class="">Madárnyelv számokkal és listával</a>
              <li><a href="index.html#4" class="">Számok listában</a>
            </ol>    </nav>
  </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Megfordít">
<div class="slide" id="slide_1">

<a id="1" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">1</span><span class="oldalszamafter">. </span>    Megfordít<a class="hlink" href="index.html#1"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>Fordítsunk meg egy listát az elemei átláncolása által! Írjunk egy programot, amely beolvas
számokat 0-ig, és kiírja a keletkező listát eredeti sorrendjében (és ezáltal a számokat eredeti
sorrendjükben), továbbá kiírja a megfordítottat is.</p>

<details >
<summary>Megoldás</summary>
<div>

<p>Ez egyszerűbb, mint gondolnánk. Ha mindig a lista elejéről elveszünk egy elemet, és a 
megfordított lista elejére betesszük azt, akkor a lista éppen megfordul! Az eredeti lista szép 
lassan elfogy, és mikor ez megtörténik, akkor a keletkező lista kész.</p>

<img src="listamegfordit.svg" style="width: 26em;" class="kozep">

<pre   ><code class="language-c">/* Megfordit egy parameterkent kapott listat, es visszater
 * a megforditott valtozattal.
 * Vigyazat, az eredeti lista elveszik! A fuggveny nem uj
 * listat epit, hanem az eredeti lista elemeinek felhasznalasaval
 * epiti az uj listat. Igy a kapott pointert legjobb az eredeti
 * lista eleje pointerbe visszairni:
 *   szamok = lista_megfordit(szamok);
 */
Szam *lista_megfordit(Szam *lista) {
    Szam *eredeti = lista;
    Szam *megforditott = NULL;

    while (eredeti != NULL) {
        Szam *atrakott = eredeti, *kovetkezo = eredeti-&gt;kov;
        atrakott-&gt;kov = megforditott;   /* uj elejere be */   /* 1 */
        megforditott = atrakott;                              /* 2 */
        eredeti = kovetkezo;            /* regibol kihagy */  /* 3 */
    }

    return megforditott;
}</code></pre>

<p>A teljes program letölthető innen: <a href="listamegfordit.c">listamegfordit.c</a>.</p>

</div>
</details>








  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Adott tulajdonságú elemek törlése">
<div class="slide" id="slide_2">

<a id="2" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">2</span><span class="oldalszamafter">. </span>    Adott tulajdonságú elemek törlése<a class="hlink" href="index.html#2"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>Adott egy szavakat tartalmazó lista. Töröljük ki belőle a négybetűseket!</p>

<details >
<summary>Megoldás</summary>
<div>

<p>A törlésnél a törölt elem <em>előtti</em> elemben lévő mutatót kell módosítani, hogy átugorja a törölt elemet. Ezért
legjobban akkor járunk, ha lemaradó pointeres ciklust írunk. Így a törlés könnyen elvégezhető:</p>

<ul>
    <li>Az előző (lemaradó pointer által mutatott) elem következő pointerét a törlendő utánira állítjuk.</li>
    <li>Ezek után a törlendő elem felszabadítható.</li>
</ul>

<img src="lista11tobbi.svg" style="width: 48em;" class="kozep">

<p>Két dologra kell figyelnünk. Egyik az, hogy törlés esetén a mozgó pointert még a felszabadítás előtt léptetnünk
kell a következő elemre. Ez azért fontos, mert a törlendő elem tartalmazza a következő elem címét, vagyis ezt törlés
után már nem tudnánk megtenni.</p>

<p>Másik dolog pedig az, hogy előfordulhat az az eset is, amikor az első elemet kell törölni. Ilyenkor nem az őt megelőző
elem következő pointerét kell módosítani (hiszen nincs őt megelőző elem), hanem a lista elejét mutató változót.</p>

<img src="lista11eleje.svg" style="width: 25em;" class="float">

<p>Egy elem törlése esetén a lemaradó pointer nem módosul a következő elemre lépéskor. Csak akkor, ha törlés nélkül megyünk
tovább a ciklusban. A törlést végző függvény:</p>

<pre   ><code class="language-c">/* Torli a negy betus szavakat a listabol. Visszater a lista
 * eleje mutatoval, amely valtozhatott, hiszen a lista elejen is
 * lehetett negy betus szo. Hasznalata:
 *   szavak = torol_negybetus(szavak);
 */
Szo *torol_negybetus(Szo *lista) {
    Szo *lemarado = NULL;
    Szo *mozgo = lista;
    
    while (mozgo != NULL) {
        if (strlen(mozgo-&gt;szo) == 4) { /* törölni? */
            Szo *torlendo = mozgo;
            mozgo = mozgo-&gt;kov;
            if (lemarado == NULL) {    /* első elem? */
                lista = torlendo-&gt;kov;
            } else {                   /* köztes elem */
                lemarado-&gt;kov = torlendo-&gt;kov;
            }
            free(torlendo);
        } else {                       /* nincs törlés */
            lemarado = mozgo;
            mozgo = mozgo-&gt;kov;
        }
    }
    return lista;
}</code></pre>

<p>A teljes program letölthető innen: <a href="torles11.c">torles11.c</a>.</p>

</div>
</details>




  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Madárnyelv számokkal és listával">
<div class="slide" id="slide_3">

<a id="3" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">3</span><span class="oldalszamafter">. </span>    Madárnyelv számokkal és listával<a class="hlink" href="index.html#3"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>Adott egy egész számokat tartalmazó lista. Írjunk be minden páros szám után egy nullát
és a számot magát. Vagyis legyen a 2,3,4,5 listából a 2,<strong>0,2,</strong>3,4,<strong>0,4,</strong>5 lista.</p>

<details >
<summary>Megoldás</summary>
<div>

<p>Ez könnyű, hiszen beszúrni egy adott elem <em>után</em> könnyen tudunk. Végigmegyünk a 
listán, ha az páros, akkor beszúrunk utána egy nullát és saját magát. Vigyázat, két buktató is 
van! Ha ilyen sorrendben tennénk, akkor fordított lenne az eredmény – vagyis előbb saját magát, 
és utána a nullát kell beszúrni. (Ehhez inkább külön változókat használ a lenti kód.) Figyelni 
kell arra is, hogy a beszúrás után az iterátort léptessük, nehogy a következő körben megtaláljuk 
a nullát vagy a beszúrt számot (hiszen ezek is párosak). Kettővel léptetjük előre, ezáltal olyan 
állapotot előidézve, mintha a ciklusváltozó a beszúrt elemre mutatna.</p>

<img src="lista202.svg" style="width: 32em;" class="kozep">

<pre   ><code class="language-c">/* A listában minden páros szám után beszúr egy nullát,
 * és még egyszer magát a számot.
 */
void lista_202(Szam *lista) {
    for (Szam *iter = lista; iter != NULL; iter = iter-&gt;kov)
        if (iter-&gt;szam % 2 == 0) {
            Szam *ujszam, *ujnulla;
            ujszam = (Szam*) malloc(sizeof(Szam));
            ujszam-&gt;szam = iter-&gt;szam;
            ujszam-&gt;kov = iter-&gt;kov;
            ujnulla = (Szam*) malloc(sizeof(Szam));
            ujnulla-&gt;szam = 0;
            ujnulla-&gt;kov = ujszam;
            iter-&gt;kov = ujnulla;
            /* 2-t ugrunk, es utana meg jon a 3. ugras */
            iter = iter-&gt;kov-&gt;kov;
        }
}</code></pre>

<p>
Az 1-2. lépést, vagyis a szám és a pointer másolását összevonhatnánk
egy lépésbe:
</p>
<pre   ><code class="language-c">*ujszam = *iter;</code></pre>
<p>Struktúra értékadással, ugyanis mind a számot, mind a pointert, vagyis az
egész struktúrát másoljuk ott.</p>

<p>A teljes program letölthető innen: <a href="lista202.c">lista202.c</a>.</p>

</div>
</details>







  
    </div>

<div class="clear"></div>

</div>
</section>


<section class="slidescreen" data-title="Számok listában">
<div class="slide" id="slide_4">

<a id="4" class="namer"></a>

<div class="slideheader">
  <h2 class="slidetitle">
    <span class="oldalszam">4</span><span class="oldalszamafter">. </span>    Számok listában<a class="hlink" href="index.html#4"><i class="hlink"></i></a>
  </h2>
</div>

<div class="slidecontent">
  
<p>Írjunk programot, amely a billentyűzetről számokat olvas be, egészen 0-ig. Írjuk ki ezután a beolvasott számok
közül azokat, amelyek az átlagnál kisebbek! A sorrend nem számít.</p>

<details >
<summary>Megoldás</summary>
<div>

<p>Tudjuk, hogy a számokat el kell tárolni, mivel csak a legutolsó szám után derül ki az, hogy
melyeket kell kiírni. A „tetszőlegesen sok” miatt listát kell alkalmaznunk. Kérdés, hogy
egyszeresen vagy kétszeresen láncolt kell legyen. Mivel a kiírás sorrendje nem kötött,
válasszunk egy egyszeresen láncolt listát, annak is a legegyszerűbb beszúró függvényét: a lista
elejére beszúrást!</p>

<p>A fentiek alapján a lista:</p>

<pre   ><code class="language-c">typedef struct Szam {
    int szam;
    struct Szam *kov;
} Szam;</code></pre>

<p>A főprogram szinte nem különbözik attól, mintha tömbbel csinálnánk:</p>

<pre   ><code class="language-c">int main(void) {
    Szam *lista = NULL;

    int beolv;
    scanf(&quot;%d&quot;, &amp;beolv);
    while (beolv != 0) {
        lista = elejere(lista, beolv);
        scanf(&quot;%d&quot;, &amp;beolv);
    }

    double atlag = listaatlag(lista);

    for (Szam *iter = lista; iter != NULL; iter = iter-&gt;kov)
        if (iter-&gt;szam &lt; atlag)
            printf(&quot;%d &quot;, iter-&gt;szam);

    felszabadit(lista);

    return 0;
}</code></pre>

<p>Ha nem használnánk külön változót a beolvasott számnak, hanem egyenesen
a listába szeretnénk beolvasni, akkor itt most nagy bajban lennénk. Ugyanis
a beolvasás előtt már létre kellene hozni egy listaelemet, amit aztán ki kellene
törölni, ha nullát olvastunk be.</p>

<p>A listába beszúrás: mindig az elejére tesszük az új számot (ezért amúgy fordított
sorrendben lesznek benne):</p>

<img src="listaverem.svg" style="width: 20em;" class="float">

<pre   ><code class="language-c">/* uj elemet szur be a megadott lista elejere.
 * visszater az uj, megvaltozott lista eleje
 * mutatoval. a hasznalata:
 * l = beszur(l, 5);
 */
Szam *elejere(Szam *lista, int szam) {
    Szam *uj = (Szam*) malloc(sizeof(Szam)); /* 1 */
    uj-&gt;szam = szam;
    uj-&gt;kov = lista;                         /* 2 */
    return uj;                               /* 3 */
}</code></pre>

<p>A lista elemeinek átlaga végülis ugyanolyan, mintha tömbünk lenne. Csak itt meg is kell 
számolnunk az elemeket:</p>

<pre   ><code class="language-c">/* a megadott listan levo szamok atlagat adja */
double listaatlag(Szam *lista) {
    double szum = 0;
    int db = 0;
    for (Szam *iter = lista; iter != NULL; iter = iter-&gt;kov) {
        szum += iter-&gt;szam;
        db++;
    }
    return szum / db; /* double/int oke */
}</code></pre>

<p>A teljes program letölthető ide kattitva: <a href="szamoklistaban.c">szamoklistaban.c</a>.</p>

</div>
</details>

  
    </div>

<div class="clear"></div>

</div>
</section>

</div>
</main>

<footer role="contentinfo">
<div class="shaper">
<div class="footer ">
  <a href="../index/index.html"><img src="../modulz/logo.png" class="footerlogo" alt="Logo"></a>
<div>InfoC – Programozás alapjai I.</div>
<div class="csakkepernyon">
            <a href="../index/index.html">főoldal</a>
         ·     <a href="../elerhetoseg/index.html">elérhetőség</a>
         ·     <a href="../elerhetoseg/index.html#licenc">licenc</a>
         ·     <a href="https://www.facebook.com/infoceetbmehu">facebook</a>
    </div>
<div class="csaknyomtatasban">Kérjük, az oldalak kinyomtatása előtt gondolj a környezetre.</div>
BME EET, 2009-2021.</div>
</div>
</footer>

</div>

<nav>
<a id="scrolltotop"></a>
</nav>

</body>

</html>
